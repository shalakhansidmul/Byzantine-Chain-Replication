# -*- generated by 1.0.11 -*-
import da
PatternExpr_538 = da.pat.TuplePattern([da.pat.ConstantPattern('configuration'), da.pat.FreePattern('config'), da.pat.FreePattern('replicas_k')])
PatternExpr_594 = da.pat.TuplePattern([da.pat.ConstantPattern('new_config_response'), da.pat.FreePattern('signed_notification')])
PatternExpr_670 = da.pat.TuplePattern([da.pat.ConstantPattern('error')])
PatternExpr_675 = da.pat.FreePattern('some_replica')
PatternExpr_2016 = da.pat.TuplePattern([da.pat.ConstantPattern('response'), da.pat.FreePattern('id'), da.pat.FreePattern('response')])
PatternExpr_2024 = da.pat.FreePattern('replica')
PatternExpr_2077 = da.pat.TuplePattern([da.pat.ConstantPattern('public_key_received'), da.pat.FreePattern('replicas_key_hex'), da.pat.FreePattern('olympus_key_hex')])
PatternExpr_2086 = da.pat.FreePattern('olympus')
_config_object = {'channel': {'fifo', 'reliable'}, 'clock': 'lamport'}
import os
import sys
import logging
import time
import datetime
import nacl
import pickle
import random
from collections import OrderedDict

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_538, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_537]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_594, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_593]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_670, sources=[PatternExpr_675], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_669]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_2016, sources=[PatternExpr_2024], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_2015]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_2077, sources=[PatternExpr_2086], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_2076])])

    def setup(self, args, olympus, master, client_id, **rest_2274):
        super().setup(args=args, olympus=olympus, master=master, client_id=client_id, **rest_2274)
        self._state.args = args
        self._state.olympus = olympus
        self._state.master = master
        self._state.client_id = client_id
        self._state.timeout = self._state.args['client_timeout']
        self._state.test123 = False
        self._state.operations = self._state.args[((('workload' + '[') + str(self._state.client_id)) + ']')]
        self._state.responses = OrderedDict()
        self._state.request_id = 0
        self._state.pending_operations = OrderedDict()
        self._state.olympus = self._state.olympus
        self._state.master = self._state.master
        self._state.configuration = OrderedDict()
        self._state.prev_configuration = OrderedDict()
        self._state.replied = []
        self._state.unique_response = OrderedDict()
        self._state.handshake = False
        self._state.private_key = nacl.signing.SigningKey.generate()
        self._state.public_key = self._state.private_key.verify_key
        self._state.replicas_public_key = OrderedDict()
        self._state.olympus_public_key = None
        self._state.error_flag = False
        self._state.client_id = self._state.client_id
        self._state.quorum = (self._state.args['t'] + 1)
        self._state.data = OrderedDict()
        self._state.resp_from_olympus = None
        self._state.logger = self.initialize_logger(self._state.args['test_case_name'])
        self._state.logger.info('Client setup completed')
        self._state.logger.info('initial settings: client ID : %s \n workload : %s', self._state.client_id, self._state.operations)
        self._state.pseudorandom_key = (('pseudooperations[' + str(self._state.client_id)) + ']')
        if (self._state.pseudorandom_key in self._state.args):
            self._state.pseudooperations = self._state.args[self._state.pseudorandom_key]
        else:
            self._state.pseudooperations = "put('movie','star'); get('movie');append('movie',' wars');put('jedi','luke skywalker'); slice('jedi','0:4'); get('jedi');"

    def run(self):
        self._state.operations = self.get_operations()
        for operation in self._state.operations:
            self.perform_operation(operation)
            request = self.build_signed_request(self._state.request_id, operation)
            self.send_request(request, operation, self._state.request_id)
            self.output('completed request: ', self._state.request_id)
            self._state.request_id += 1
        self._state.logger.info('all operations executed. sending DONE message to olympus')
        self.send('done', to=self._state.olympus)
        self._state.logger.info('Message sent: %s', 'done')
        self.send(('client_final_state', self._state.client_id, self._state.data), to=self._state.master)
        self._state.logger.info('Final state of the client: %s', self._state.data)
        super()._label('_st_label_1777', block=False)
        _st_label_1777 = 0
        while (_st_label_1777 == 0):
            _st_label_1777 += 1
            if self._state.test123:
                _st_label_1777 += 1
            else:
                super()._label('_st_label_1777', block=True)
                _st_label_1777 -= 1

    def initialize_logger(self, test_case_name):
        self._state.logger = logging.getLogger(('Client' + str(self._state.client_id)))
        self._state.logger.setLevel(logging.DEBUG)
        path = ((('Client' + str(self._state.client_id)) + '-log-') + test_case_name)
        fh = logging.FileHandler(path)
        fh.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        fh.setFormatter(formatter)
        self._state.logger.addHandler(fh)
        return self._state.logger

    def update_configuration(self, config, replicas_k):
        self._state.configuration = config
        replica_id = 0
        for key in replicas_k:
            replica_public_key = nacl.signing.VerifyKey(key, encoder=nacl.encoding.HexEncoder)
            replica = ('replica' + str(replica_id))
            self._state.replicas_public_key[replica] = replica_public_key
            replica_id += 1
        self._state.logger.info('configuration updated successfully. new configuration is : %s', self._state.configuration)

    def request_config_from_olympus(self):
        self._state.prev_configuration = self._state.configuration
        self._state.configuration = {}
        self.send(('request_configuration', self._id, self._state.client_id), to=self._state.olympus)
        self._state.logger.info('requesting configuration from olympus : \n message sent: %s', ('request_configuration', self._id, self._state.client_id))
        super()._label('_st_label_711', block=False)
        _st_label_711 = 0
        self._timer_start()
        while (_st_label_711 == 0):
            _st_label_711 += 1
            if (len(self._state.configuration) > 0):
                if (not self._state.handshake):
                    self._state.logger.info('handshake not performed. sending public key to olympus.')
                    public_key_hex = self._state.public_key.encode(encoder=nacl.encoding.HexEncoder)
                    self.send(('client_public_key', self._state.client_id, public_key_hex), to=self._state.olympus)
                    self._state.logger.info('sent public key to olympus. \n message sent: %s', ('client_public_key', self._state.client_id, self._id, public_key_hex))
                    super()._label('_st_label_751', block=False)
                    _st_label_751 = 0
                    while (_st_label_751 == 0):
                        _st_label_751 += 1
                        if self._state.handshake:
                            _st_label_751 += 1
                        else:
                            super()._label('_st_label_751', block=True)
                            _st_label_751 -= 1
                    self._state.logger.info('handshake completed')
                _st_label_711 += 1
            elif self._timer_expired:
                self._state.logger.warning('configuration request timed out. no response from olympus.')
                self.request_config_from_olympus()
                _st_label_711 += 1
            else:
                super()._label('_st_label_711', block=True, timeout=self._state.timeout)
                _st_label_711 -= 1

    def resend_request_to_all_replicas(self, request):
        self.request_config_from_olympus()
        for i in range(len(self._state.configuration)):
            self._state.logger.info('retransmitting request to replica %s ', i)
            self.send(('request', request), to=self._state.configuration[('replica' + str(i))])
            self._state.logger.info('message sent: %s', ('request', request))

    def get_hashed_result(self, result):
        HASHER = nacl.hash.sha256
        result_bytes = pickle.dumps(result)
        digest = HASHER(result_bytes, encoder=nacl.encoding.HexEncoder)
        result_bytes = pickle.dumps(result)
        digest = HASHER(result_bytes, encoder=nacl.encoding.HexEncoder)
        self._state.logger.info('received result : %s \ncrptpgraphic hash of the result: %s', result, digest)
        return digest

    def validate_result_statement(self, cryptographic_hash_of_result, result_statement, replica_verify_key, i):
        try:
            verified_result_statement = replica_verify_key.verify(result_statement)
            unpickled_result_statement = pickle.loads(verified_result_statement)
            if (not (cryptographic_hash_of_result == unpickled_result_statement[2])):
                self._state.logger.warning('validation failed for  result statement of replica %s', i)
                return False
            return True
        except BaseException:
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            self._state.logger.error('Exception occurred in validating result statement\n Type: %s', exc_type)
            return False

    def validate(self, response_from_replica):
        count = 0
        (result, result_proof) = response_from_replica
        result_statements = result_proof[3]
        cryptographic_hash_of_result = self.get_hashed_result(result)
        for i in range(len(self._state.configuration)):
            result_statement = result_statements[i]
            replica_verify_key = self._state.replicas_public_key[('replica' + str(i))]
            self._state.logger.info('validating result statement of replica %s', i)
            if self.validate_result_statement(cryptographic_hash_of_result, result_statement, replica_verify_key, i):
                count += 1
        if (count == len(self._state.configuration)):
            return (result, False)
        if (count >= self._state.quorum):
            return (result, True)
        return (None, True)

    def accept_result(self, id):
        self._state.logger.debug('checking if received result for request_id %s can be accepted', id)
        valid_responses = []
        reconfig_requested = False
        reconfig_required = False
        for i in range(len(self._state.replied)):
            (result, reconfig_flag) = self.validate(self._state.replied[i])
            if result:
                if ((not valid_responses) or (result == valid_responses[0])):
                    valid_responses.append(result)
                    self._state.logger.debug('valid result received for request_id %s', id)
            if reconfig_flag:
                reconfig_required = True
                proof_of_misbehaviour = self._state.replied[i]
        if (len(self._state.replied) == 1):
            if ((not (len(valid_responses) == 1)) or reconfig_required):
                self._state.replied = []
                self._state.unique_response = OrderedDict()
                self._state.logger.warning(('Replica misbehaviour detected.' + ' Requesting Olympus for reconfiguration '))
                signed_proof_of_misbehaviour = self._state.private_key.sign(pickle.dumps(proof_of_misbehaviour))
                self.send(('request_reconfiguration_from_client', signed_proof_of_misbehaviour), to=self._state.olympus)
                self._state.logger.debug('Message sent: %s', ('request_reconfiguration_from_client', proof_of_misbehaviour))
                return False
        else:
            if ((not (len(valid_responses) == len(self._state.configuration))) or reconfig_required):
                self._state.logger.warning('Valid response not received from all replicas')
                self._state.logger.warning('Requesting Olympus for reconfiguration')
                signed_proof_of_misbehaviour = self._state.private_key.sign(pickle.dumps(proof_of_misbehaviour))
                self.send(('request_reconfiguration_from_client', signed_proof_of_misbehaviour), to=self._state.olympus)
                self._state.logger.debug('Message sent: %s', ('request_reconfiguration_from_client', proof_of_misbehaviour))
            if (len(valid_responses) < self._state.quorum):
                self._state.logger.warning('Valid response not received from quorum of replicas')
                self._state.logger.warning('Response not accepted for request id: %s', self._state.quorum)
                self._state.replied = []
                self._state.unique_response = OrderedDict()
                return False
        self._state.logger.debug('Accepting result: %s  for request id: %s ', valid_responses[0], id)
        self._state.responses[id] = valid_responses[0]
        del self._state.pending_operations[id]
        self._state.logger.info('deleting the request id %s from pending operations %s', id, self._state.pending_operations)
        self._state.replied = []
        self._state.unique_response = OrderedDict()
        return True

    def build_signed_request(self, request_id, operation):
        self._state.logger.info('building signed request for request id: %s and operation: %s', request_id, operation)
        request = (self._state.client_id, self._id, request_id, operation)
        pickled_request = pickle.dumps(request)
        signed_request = self._state.private_key.sign(pickled_request)
        return signed_request

    def send_request_to_replicas(self, request_id, request):
        self._state.logger.info('retransmtting request to all replicas')
        self._state.replied = []
        self._state.unique_response = OrderedDict()
        self.resend_request_to_all_replicas(request)
        super()._label('_st_label_1286', block=False)
        _st_label_1286 = 0
        self._timer_start()
        while (_st_label_1286 == 0):
            _st_label_1286 += 1
            if (len(self._state.replied) == len(self._state.configuration)):
                self._state.logger.debug('received reply from all replicas')
                if (not self.accept_result(request_id)):
                    return False
                self._state.logger.info('retransmission successful for request with id: %s', request_id)
                return True
                _st_label_1286 += 1
            elif self._state.resp_from_olympus:
                if (not self.accept_response_from_olympus(self._state.resp_from_olympus)):
                    self._state.resp_from_olympus = None
                    if (not self.send_request_to_replicas(request_id, request)):
                        self.handle_error_flag(request_id, request)
                return True
                _st_label_1286 += 1
            elif self._state.error_flag:
                self._state.logger.warning('error statement received')
                return False
                _st_label_1286 += 1
            elif self._timer_expired:
                self._state.logger.info('retransmission timed out. retrying retransmission.')
                if (not self.send_request_to_replicas(request_id, request)):
                    return False
                return True
                _st_label_1286 += 1
            else:
                super()._label('_st_label_1286', block=True, timeout=self._state.timeout)
                _st_label_1286 -= 1

    def get_operations_set(self):
        self._state.operations = self._state.pseudooperations
        self._state.operations = self._state.operations.split(';')
        valid_operations = []
        for i in range(len(self._state.operations)):
            operation = self._state.operations[i].strip()
            if len(operation):
                valid_operations.append(operation)
        return valid_operations

    def generate_random_operations(self, seed, sequences_count):
        random.seed(seed)
        operations_set = self.get_operations_set()
        sequence_list = []
        for _ in range(sequences_count):
            sequence_list.append(random.randint(0, (len(operations_set) - 1)))
        self._state.operations = []
        for index in sequence_list:
            self._state.operations.append(operations_set[index])
        self._state.logger.info('random operations generated: %s', self._state.operations)
        return self._state.operations

    def get_operations(self):
        self._state.operations = self._state.operations.split(';')
        valid_operations = []
        for i in range(len(self._state.operations)):
            operation = self._state.operations[i].strip()
            if len(operation):
                valid_operations.append(operation)
        self._state.operations = valid_operations
        if ('pseudorandom' in valid_operations[0]):
            operation = valid_operations[0]
            operation = operation.split(',')
            seed = operation[0][13:]
            sequences_count = int(operation[1][:(- 1)])
            valid_operations = self.generate_random_operations(seed, sequences_count)
        self._state.logger.info('valid operations : %s', valid_operations)
        return valid_operations

    def perform_operation(self, operation):
        result = None
        val = None
        op = operation.split("'")
        key = op[1]
        if ('put' in operation):
            value = op[3]
            self._state.data[op[1]] = op[3]
            val = 'OK'
        elif ('get' in operation):
            if (key in self._state.data):
                val = self._state.data[key]
            else:
                val = ''
        elif ('slice' in operation):
            slice = op[3].split(':')
            start_index = int(slice[0])
            end_index = int(slice[1])
            if (key in self._state.data):
                value = self._state.data[key]
                if ((start_index < end_index) and (end_index <= len(value))):
                    self._state.data[key] = value[start_index:end_index]
                    val = 'OK'
                else:
                    val = 'fail'
            else:
                val = 'fail'
        elif ('append' in operation):
            value = op[3]
            if (key in self._state.data):
                self._state.data[key] += value
                val = 'OK'
            else:
                val = 'fail'
        result = (val,)
        self._state.logger.debug('data: %s operation: %s result: %s ', self._state.data, operation, val)

    def send_request(self, request, operation, request_id):
        self.request_config_from_olympus()
        head = self._state.configuration['replica0']
        self.send(('request', request), to=head)
        self._state.logger.info('request with request id %s sent to head:', request_id)
        self._state.pending_operations[request_id] = operation
        self._state.replied = []
        self._state.unique_response = OrderedDict()
        super()._label('_st_label_1818', block=False)
        _st_label_1818 = 0
        self._timer_start()
        while (_st_label_1818 == 0):
            _st_label_1818 += 1
            if (len(self._state.replied) == 1):
                if (not self.accept_result(request_id)):
                    self._state.logger.warning(('Response not accepted: request id %s operation: %s.' + ' Setting error flag to True.'), request_id, operation)
                    self._state.error_flag = True
                    self.handle_error_flag(request_id, request)
                _st_label_1818 += 1
            elif self._state.resp_from_olympus:
                if (not self.accept_response_from_olympus(self._state.resp_from_olympus)):
                    self._state.logger.info('response from olympus not accepted')
                    self._state.resp_from_olympus = None
                    self._state.logger.info(('Configuration change detected.' + ' Sending request to HEAD of new Configuration'))
                    self.send_request(request, operation, request_id)
                _st_label_1818 += 1
            elif self._state.error_flag:
                self.handle_error_flag(request_id, request)
                _st_label_1818 += 1
            elif self._timer_expired:
                self._state.logger.warning('request timed out for request id %s operation: %s', request_id, operation)
                if (not self.send_request_to_replicas(request_id, request)):
                    self.handle_error_flag(request_id, request)
                _st_label_1818 += 1
            else:
                super()._label('_st_label_1818', block=True, timeout=self._state.timeout)
                _st_label_1818 -= 1

    def handle_error_flag(self, req_id, request):
        self.send(('request_configuration', self._id, self._state.client_id), to=self._state.olympus)
        self._state.logger.info('requesting configuration. \n Message sent: %s', ('request_configuration', self._id, self._state.client_id))
        super()._label('_st_label_1920', block=False)
        _st_label_1920 = 0
        while (_st_label_1920 == 0):
            _st_label_1920 += 1
            if (self._state.error_flag == False):
                _st_label_1920 += 1
            else:
                super()._label('_st_label_1920', block=True)
                _st_label_1920 -= 1
        super()._label('_st_label_1925', block=False)
        _st_label_1925 = 0
        self._timer_start()
        while (_st_label_1925 == 0):
            _st_label_1925 += 1
            if self._state.resp_from_olympus:
                self.accept_response_from_olympus(self._state.resp_from_olympus)
                self._state.resp_from_olympus = None
                if (req_id in self._state.pending_operations):
                    self._state.logger.debug(('req_id in pending operations.' + ' sending request to head of new configuration'))
                    head = self._state.configuration['replica0']
                    self.send(('request', request), to=head)
                    super()._label('_st_label_1958', block=False)
                    _st_label_1958 = 0
                    self._timer_start()
                    while (_st_label_1958 == 0):
                        _st_label_1958 += 1
                        if (len(self._state.replied) == 1):
                            if (not self.accept_result(req_id)):
                                self._state.logger.warning('Response not accepted: request id %s ', req_id)
                                self._state.error_flag = True
                                self.handle_error_flag(req_id, request)
                            _st_label_1958 += 1
                        elif self._timer_expired:
                            self._state.logger.warning('request timed out for request id %s', req_id)
                            if (not self.send_request_to_replicas(req_id, request)):
                                self.handle_error_flag(req_id, request)
                            elif self._state.error_flag:
                                self.handle_error_flag(req_id, request)
                            _st_label_1958 += 1
                        else:
                            super()._label('_st_label_1958', block=True, timeout=self._state.timeout)
                            _st_label_1958 -= 1
                _st_label_1925 += 1
            elif self._timer_expired:
                self.handle_error_flag(req_id, request)
                _st_label_1925 += 1
            else:
                super()._label('_st_label_1925', block=True, timeout=self._state.timeout)
                _st_label_1925 -= 1

    def accept_response_from_olympus(self, signed_response):
        (req_id, response, replicas_id) = pickle.loads(self._state.olympus_public_key.verify(signed_response))
        self._state.logger.info('pending operations are %s %s ', self._state.pending_operations, (not (req_id in self._state.pending_operations)))
        if (not (req_id in self._state.pending_operations)):
            self._state.logger.info(('received response from olympus for request id' + ' which is not in pending operations'))
            return False
        self._state.logger.info('response received from olympus for request id: %s', req_id)
        (res, r_proof) = response
        r_stmts = r_proof[3]
        cryptographic_hash_of_res = self.get_hashed_result(res)
        for i in range(len(replicas_id)):
            result_statement = r_stmts[i]
            replica_verify_key = self._state.replicas_public_key[('replica' + str(replicas_id[i]))]
            self._state.logger.info('validating result statement of replica %s', i)
            if (not self.validate_result_statement(cryptographic_hash_of_res, result_statement, replica_verify_key, i)):
                return False
        self._state.logger.debug('Accepting result: %s  for request id: %s ', res, req_id)
        self._state.responses[req_id] = res
        del self._state.pending_operations[req_id]
        self._state.resp_from_olympus = None
        return True

    def _Client_handler_537(self, config, replicas_k):
        self._state.logger.info('configuration received from olympus: %s', config)
        self._state.configuration = config
        replica_id = 0
        for key in replicas_k:
            replica_public_key = nacl.signing.VerifyKey(key, encoder=nacl.encoding.HexEncoder)
            replica = ('replica' + str(replica_id))
            self._state.replicas_public_key[replica] = replica_public_key
            replica_id += 1
    _Client_handler_537._labels = None
    _Client_handler_537._notlabels = None

    def _Client_handler_593(self, signed_notification):
        (config, replicas_k, signed_response) = pickle.loads(self._state.olympus_public_key.verify(signed_notification))
        self._state.logger.info('new configuration received from olympus: %s', config)
        self.update_configuration(config, replicas_k)
        (req_id, response, replicas_id) = pickle.loads(self._state.olympus_public_key.verify(signed_response))
        if (req_id in self._state.pending_operations):
            self._state.resp_from_olympus = signed_response
            self._state.logger.info('response received from olympus : %s', signed_response)
        else:
            self._state.logger.info(('received response from olympus for request id' + ' which is not in pending operations'))
        self._state.error_flag = False
        self._state.handshake = True
    _Client_handler_593._labels = None
    _Client_handler_593._notlabels = None

    def _Client_handler_669(self, some_replica):
        self._state.logger.info('error statement received from replica : %s', some_replica)
        self._state.error_flag = True
    _Client_handler_669._labels = None
    _Client_handler_669._notlabels = None

    def _Client_handler_2015(self, id, response, replica):
        self._state.logger.info('response received for request id: %s from: %s \nresponse: %s ', id, replica, response)
        if (not (replica in self._state.unique_response)):
            self._state.unique_response[replica] = response
            self._state.replied.append(response)
        elif (not (response == self._state.unique_response[replica])):
            self._state.replied.remove(self._state.unique_response[replica])
            self._state.unique_response[replica] = response
            self._state.replied.append(response)
    _Client_handler_2015._labels = None
    _Client_handler_2015._notlabels = None

    def _Client_handler_2076(self, replicas_key_hex, olympus_key_hex, olympus):
        replica_id = 0
        self._state.olympus_public_key = nacl.signing.VerifyKey(olympus_key_hex, encoder=nacl.encoding.HexEncoder)
        for key in replicas_key_hex:
            replica_public_key = nacl.signing.VerifyKey(key, encoder=nacl.encoding.HexEncoder)
            replica = ('replica' + str(replica_id))
            self._state.replicas_public_key[replica] = replica_public_key
            replica_id += 1
        self._state.logger.info('public keys received for %s replicas in current configuration', len(replicas_key_hex))
        self._state.handshake = True
    _Client_handler_2076._labels = None
    _Client_handler_2076._notlabels = None
