# -*- generated by 1.0.11 -*-
import da
PatternExpr_962 = da.pat.ConstantPattern('done')
PatternExpr_966 = da.pat.FreePattern('client')
PatternExpr_981 = da.pat.TuplePattern([da.pat.ConstantPattern('request_configuration'), da.pat.FreePattern('sender'), da.pat.FreePattern('client_id')])
PatternExpr_990 = da.pat.FreePattern('sender')
PatternExpr_1037 = da.pat.TuplePattern([da.pat.ConstantPattern('client_public_key'), da.pat.FreePattern('client_id'), da.pat.FreePattern('key')])
PatternExpr_1046 = da.pat.FreePattern('sender')
PatternExpr_1101 = da.pat.TuplePattern([da.pat.ConstantPattern('replica_final_state'), da.pat.FreePattern('replica_id'), da.pat.FreePattern('data')])
PatternExpr_1826 = da.pat.TuplePattern([da.pat.ConstantPattern('init_running_state'), da.pat.FreePattern('signed_rs')])
PatternExpr_1833 = da.pat.FreePattern('rpl')
PatternExpr_2631 = da.pat.TuplePattern([da.pat.ConstantPattern('request_reconfiguration'), da.pat.FreePattern('reconfiguration_request')])
PatternExpr_2638 = da.pat.FreePattern('replica')
PatternExpr_2865 = da.pat.TuplePattern([da.pat.ConstantPattern('wedged'), da.pat.FreePattern('wedged_statement')])
PatternExpr_2872 = da.pat.FreePattern('replica')
PatternExpr_2974 = da.pat.TuplePattern([da.pat.ConstantPattern('caught_up'), da.pat.FreePattern('signed_caught_up_message')])
PatternExpr_2981 = da.pat.FreePattern('replica')
PatternExpr_3004 = da.pat.TuplePattern([da.pat.ConstantPattern('request_reconfiguration_from_client'), da.pat.FreePattern('signed_proof_of_misbehaviour')])
PatternExpr_3011 = da.pat.FreePattern('client')
PatternExpr_3300 = da.pat.TuplePattern([da.pat.ConstantPattern('test_resp'), da.pat.FreePattern('val')])
PatternExpr_3307 = da.pat.FreePattern('repl')
_config_object = {'channel': {'fifo', 'reliable'}, 'clock': 'lamport'}
import os
import sys
import logging
import time
import datetime
import pickle
import copy
import nacl.encoding
import nacl
import nacl.signing
from nacl.bindings.utils import sodium_memcmp
from copy import deepcopy
from collections import OrderedDict
from itertools import combinations
da_client = da.import_da('client')
da_replica = da.import_da('replica')

class Olympus(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_0', PatternExpr_962, sources=[PatternExpr_966], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_961]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_1', PatternExpr_981, sources=[PatternExpr_990], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_980]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_2', PatternExpr_1037, sources=[PatternExpr_1046], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1036]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_3', PatternExpr_1101, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1100]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_4', PatternExpr_1826, sources=[PatternExpr_1833], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_1825]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_5', PatternExpr_2631, sources=[PatternExpr_2638], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_2630]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_6', PatternExpr_2865, sources=[PatternExpr_2872], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_2864]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_7', PatternExpr_2974, sources=[PatternExpr_2981], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_2973]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_8', PatternExpr_3004, sources=[PatternExpr_3011], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_3003]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_9', PatternExpr_3300, sources=[PatternExpr_3307], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_3299])])

    def setup(self, config, master, **rest_3325):
        super().setup(config=config, master=master, **rest_3325)
        self._state.config = config
        self._state.master = master
        self._state.config_id = (- 1)
        self._state.config = self._state.config
        self._state.configuration = OrderedDict()
        self._state.private_keys = []
        self._state.public_keys = []
        self._state.public_keys_bytes = []
        self._state.client_keys = OrderedDict()
        self._state.client_keys_bytes = OrderedDict()
        self._state.num_replicas = ((2 * self._state.config['t']) + 1)
        self._state.quorum = (self._state.config['t'] + 1)
        self._state.done_count = 0
        self._state.logger = self.initialize_logger()
        self._state.logger.info('Olympus setup completed')
        self._state.logger.info('initial settings:\n num of replicas: %s \n num of clients: %s', self._state.num_replicas, self._state.config['num_client'])
        self._state.master = self._state.master
        self._state.replica_data = OrderedDict()
        self._state.signing_key = nacl.signing.SigningKey.generate()
        self._state.verify_key_hex = self._state.signing_key.verify_key.encode(encoder=nacl.encoding.HexEncoder)
        self._state.global_wedged_statements = OrderedDict()
        self._state.clients = OrderedDict()
        self._state.caught_up_msgs = OrderedDict()
        self._state.last_checkpoint_sn = (- 1)
        self._state.consistent_running_state = None
        self._state.old_head = None
        self._state.reconfig_in_progress = False
        self._state.client_responses = OrderedDict()
        self._state.invalid_replicas = OrderedDict()
        self._state.QC = []

    def run(self):
        replicas = self.build_replicas(self._state.config)
        self.start_replicas(replicas)
        self.generate_replicas_keys()
        self.send_init_to_replicas(replicas)
        self._state.logger.info('system initialization successful')
        super()._label('_st_label_918', block=False)
        _st_label_918 = 0
        while (_st_label_918 == 0):
            _st_label_918 += 1
            if (self._state.done_count == self._state.config['num_client']):
                _st_label_918 += 1
            else:
                super()._label('_st_label_918', block=True)
                _st_label_918 -= 1
        self._state.logger.info('received DONE: all clients finished sending messages.')
        self.send_done_to_all_replicas()
        super()._label('_st_label_933', block=False)
        _st_label_933 = 0
        while (_st_label_933 == 0):
            _st_label_933 += 1
            if (len(self._state.replica_data) == self._state.num_replicas):
                _st_label_933 += 1
            else:
                super()._label('_st_label_933', block=True)
                _st_label_933 -= 1
        self._state.logger.info('received Replicas Final State.')
        self.send(('replicas_final_state', self._state.replica_data), to=self._state.master)
        self._state.logger.info('sent Replica Final States to Master')
        self._state.logger.info(' Olympus terminating')

    def initialize_logger(self):
        self._state.logger = logging.getLogger('Olympus')
        self._state.logger.setLevel(logging.DEBUG)
        fh = logging.FileHandler(('Olympus-log-' + self._state.config['test_case_name']))
        fh.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        fh.setFormatter(formatter)
        self._state.logger.addHandler(fh)
        return self._state.logger

    def generate_replicas_keys(self):
        self._state.logger.info('generating keys for all replicas')
        self._state.private_keys = []
        self._state.public_keys = []
        self._state.public_keys_bytes = []
        for i in range(self._state.num_replicas):
            private_key = nacl.signing.SigningKey.generate()
            private_key_hex = private_key.encode(encoder=nacl.encoding.HexEncoder)
            self._state.private_keys.append(private_key_hex)
            public_key = private_key.verify_key
            self._state.public_keys.append(public_key)
            public_key_hex = public_key.encode(encoder=nacl.encoding.HexEncoder)
            self._state.public_keys_bytes.append(public_key_hex)

    def build_replicas(self, config):
        self._state.config_id += 1
        replicas = OrderedDict()
        head = 'replica0'
        self._state.logger.info(' building head replica')
        replicas[head] = self.new(da_replica.Replica, args=(config, self._id, True, False, 0, self._state.config_id, self._state.verify_key_hex), at='ReplicaNode0')
        for i in range(1, (self._state.num_replicas - 1)):
            replica = ('replica' + str(i))
            self._state.logger.info(' building replica %s', i)
            replicas[replica] = self.new(da_replica.Replica, args=(config, self._id, False, False, i, self._state.config_id, self._state.verify_key_hex), at=('ReplicaNode' + str(i)))
        tail = ('replica' + str((self._state.num_replicas - 1)))
        self._state.logger.info(' building tail replica')
        replicas[tail] = self.new(da_replica.Replica, args=(config, self._id, False, True, (self._state.num_replicas - 1), self._state.config_id, self._state.verify_key_hex), at=('ReplicaNode' + str((self._state.num_replicas - 1))))
        return replicas

    def start_replicas(self, replicas):
        for i in range(self._state.num_replicas):
            replica = ('replica' + str(i))
            self._state.logger.info('starting replica %s', i)
            self._start(replicas[replica])

    def send_init_to_replicas(self, replicas, consistent_checkpoint=None, longest_history=None, running_state=None):
        self._state.configuration = replicas
        if (not self._state.reconfig_in_progress):
            for i in range(self._state.num_replicas):
                replica = ('replica' + str(i))
                self.send(('init', self._state.configuration, self._state.private_keys[i], self._state.public_keys_bytes, self._state.verify_key_hex), to=replicas[replica])
        else:
            if (consistent_checkpoint is None):
                csn = None
            else:
                csn = consistent_checkpoint[1][0]
            for i in range(self._state.num_replicas):
                replica = ('replica' + str(i))
                self.send(('init_setup', self._state.configuration, self._state.private_keys[i], self._state.public_keys_bytes, self._state.verify_key_hex, self._state.client_keys_bytes, csn, longest_history, running_state, True), to=replicas[replica])
        self._state.logger.info('initial configuration settings sent to %s replicas', self._state.num_replicas)
        self._state.logger.info('configuration sent: %s', self._state.configuration)

    def send_client_public_key_to_replicas(self, client, key):
        for replica in self._state.configuration.keys():
            self.send(('client_key', client, key), to=self._state.configuration[replica])
        self._state.logger.info(' sent client public key to all replicas')

    def send_done_to_all_replicas(self):
        for i in range(len(self._state.configuration)):
            self.send(('done',), to=self._state.configuration[('replica' + str(i))])
            self._state.logger.info('sent DONE to replica%s ', i)

    def build_quorum_combinations(self):
        for item in combinations(self._state.configuration.values(), self._state.quorum):
            self._state.QC.append(item)
        self._state.logger.info('built all quorum combinations of replicas %s', self._state.QC)

    def get_unpickled_checkpoint_statements(self, checkpoint_proof):
        self._state.logger.info('unpickling checkpoint statements')
        unpickled_checkpoint_statements = []
        for i in range(len(checkpoint_proof)):
            checkpoint_statement = checkpoint_proof[i]
            replica_verify_key = self._state.public_keys[i]
            try:
                verified_checkpoint_statement = replica_verify_key.verify(checkpoint_statement)
                unpickled_checkpoint_statement = pickle.loads(verified_checkpoint_statement)
                unpickled_checkpoint_statements.append(unpickled_checkpoint_statement)
            except BaseException:
                (exc_type, exc_value, exc_traceback) = sys.exc_info()
                self._state.logger.error((('Exception occurred in validation of' + 'result statement %s.\n') + ' Type: %s\n Value: %s\n Trace: %s'), checkpoint_statement, exc_type, exc_value, exc_traceback)
                return False
        return unpickled_checkpoint_statements

    def get_hashed_running_state(self, running_state=None):
        self._state.logger.info('generating hash of the running state')
        HASHER = nacl.hash.sha256
        rs_bytes = pickle.dumps(running_state)
        digest = HASHER(rs_bytes, encoder=nacl.encoding.HexEncoder)
        return digest

    def validate_checkpoint(self, wedged_statement):
        self._state.logger.info('validating checkpoint in wedged statement')
        running_state = wedged_statement[0]
        if (wedged_statement[1] is None):
            return False
        checkpoint_proof = wedged_statement[1][1]
        if (not (len(checkpoint_proof) == self._state.num_replicas)):
            return False
        unpickled_checkpoint_statements = self.get_unpickled_checkpoint_statements(checkpoint_proof)
        cryptographic_hash_of_running_state = self.get_hashed_running_state(running_state)
        if unpickled_checkpoint_statements:
            for i in range(len(unpickled_checkpoint_statements)):
                if (not (unpickled_checkpoint_statements[i][1] == cryptographic_hash_of_running_state)):
                    self._state.logger.error(('validation failed for cryptographic hash of running' + 'state in checkpoint statement number: %s .'), i)
                    return False
            self._state.logger.info('checkpoint validation passed')
            return True

    def get_consistent_checkpoint(self, wedged_statements):
        max_slot_num = float('-inf')
        checkpoint = None
        for (key, wedged_statement) in wedged_statements.items():
            if self.validate_checkpoint(wedged_statement):
                if (max_slot_num < wedged_statement[1][0]):
                    checkpoint = (wedged_statement[0], wedged_statement[1])
        if checkpoint:
            self._state.logger.info('consistent checkpoint is : %s', checkpoint)
            return checkpoint
        return None

    def get_init_parameters(self, wedged_statements, checkpoint_slot_number):
        self._state.logger.info('getting init parameters for replicas')
        histories = OrderedDict()
        consistent_histories = OrderedDict()
        suffix_for_consistent_histories = OrderedDict()
        for (replica, w_stmt) in wedged_statements.items():
            hist = w_stmt[2]
            self._state.logger.info(('getting history for slot numbers greater than consistent' + 'checkpoint slot number for replica: %s'), replica)
            histories[replica] = self.get_clipped_history(hist, checkpoint_slot_number)
        for (k, v) in histories.items():
            if (not self.validate_slot_number(v, checkpoint_slot_number)):
                return (False, False)
        replicas_object = []
        replicas_history = []
        for (replica, history) in sorted(histories.items(), key=(lambda x: ((- len(x[1])), x[0]))):
            replicas_object.append(replica)
            replicas_history.append(history)
            self._state.logger.info('length of history for replica : %s is %s ', replica, len(history))
        longest = 0
        consistent_histories[replicas_object[longest]] = replicas_history[longest]
        for j in range(1, self._state.quorum):
            isValid = True
            consistent = self.compare_history(replicas_history[longest], replicas_history[j])
            if consistent:
                consistent_histories[replicas_object[j]] = replicas_history[j]
                shortest = j
                self._state.logger.debug('history of replica %s consistent with replica %s', replicas_object[j], replicas_object[longest])
            else:
                self._state.logger.debug(('Inconsistent replica histories found.' + 'Choosing a different quorum.'))
                return (False, False)
        longest_consistent_history = replicas_history[longest]
        shortest_consistent_history = replicas_history[shortest]
        self._state.logger.info('longest consistent history found: %s ', longest_consistent_history)
        self._state.logger.info('shortest consistent history found: %s ', shortest_consistent_history)
        diff_history = OrderedDict()
        for k in longest_consistent_history.keys():
            if (not (k in shortest_consistent_history)):
                diff_history[k] = longest_consistent_history[k]
        for (k, v) in diff_history.items():
            isValid = self.validate_diff_history_operations(k[0], v[0][1], v[1])
            if (not isValid):
                self._state.logger.debug(('Diff history operation validation failed for %s.' + 'Choosing a different quorum.'), v[0][1])
                return (False, False)
        suffix_for_consistent_histories = self.compute_suffix(consistent_histories, longest_consistent_history)
        self.send_catch_up_to_replicas(suffix_for_consistent_histories)
        self._state.caught_up_msgs = OrderedDict()
        super()._label('_st_label_1679', block=False)
        _st_label_1679 = 0
        self._timer_start()
        while (_st_label_1679 == 0):
            _st_label_1679 += 1
            if (len(self._state.caught_up_msgs) == self._state.quorum):
                self._state.logger.debug('caught up message received from quorum replicas')
                replica_with_longest_hist = replicas_object[longest]
                running_state_hash_of_longest_hist_replica = self._state.caught_up_msgs[replica_with_longest_hist][1]
                for (k, v) in self._state.caught_up_msgs.items():
                    if (not (v[1] == running_state_hash_of_longest_hist_replica)):
                        self._state.logger.error(('hash violation found for replica : %s.' + 'Choosing a different quorum. '), k)
                        return (False, False)
                status = self.get_responses_for_clients(self._state.caught_up_msgs, replica_with_longest_hist)
                if status:
                    for r in consistent_histories.keys():
                        self.send('get_init_running_state', to=r)
                        self._state.logger.info(('asking replica %s for running state.' + '\nmessage sent:%s '), r, 'get_init_running_state')
                        super()._label('_st_label_1760', block=False)
                        _st_label_1760 = 0
                        self._timer_start()
                        while (_st_label_1760 == 0):
                            _st_label_1760 += 1
                            if (not (self._state.consistent_running_state is None)):
                                rstate = deepcopy(self._state.consistent_running_state)
                                self._state.consistent_running_state = None
                                if (running_state_hash_of_longest_hist_replica == self.get_hashed_running_state(rstate)):
                                    return (longest_consistent_history, rstate)
                                _st_label_1760 += 1
                            elif self._timer_expired:
                                self._state.logger.debug((('Consistent running state not received from' + 'replica %s in selected quorum.') + 'Asking another replica.'), r)
                                continue
                                _st_label_1760 += 1
                            else:
                                super()._label('_st_label_1760', block=True, timeout=2)
                                _st_label_1760 -= 1
                        else:
                            if (_st_label_1760 != 2):
                                continue
                        if (_st_label_1760 != 2):
                            break
                    return (False, False)
                else:
                    self._state.logger.debug(('valid client responses not obtained from replicas' + 'in selected quorum.Choosing a different quorum.'))
                    return (False, False)
                _st_label_1679 += 1
            elif self._timer_expired:
                self._state.logger.info(('caught up not received within timeout.' + 'choosing a different quorum.'))
                return (False, False)
                _st_label_1679 += 1
            else:
                super()._label('_st_label_1679', block=True, timeout=2)
                _st_label_1679 -= 1

    def get_clipped_history(self, hist, checkpoint_slot_number):
        temp_hist = OrderedDict()
        for (k, v) in hist.items():
            if (v[0][0] > checkpoint_slot_number):
                temp_hist[k] = v
        return temp_hist

    def compare_history(self, history1, history2):
        shorter_history = history2
        longer_history = history1
        i = 0
        short_hist_keys = shorter_history.keys()
        for key in short_hist_keys:
            (order_proof1, signed_client_req1) = shorter_history[key]
            if (key in longer_history):
                (order_proof2, signed_client_req2) = longer_history[key]
                slot_num1 = order_proof1[0]
                operation1 = order_proof1[1]
                slot_num2 = order_proof2[0]
                operation2 = order_proof2[1]
                if ((not (slot_num1 == slot_num2)) and (not (operation1 == operation2))):
                    return False
            else:
                return False
        self._state.logger.info('histories are consistent, returning true')
        return True

    def validate_diff_history_operations(self, client_id, operation, signed_client_request):
        try:
            client = self._state.clients[client_id]
            client_verify_key = self._state.client_keys[client]
            verified_request = client_verify_key.verify(signed_client_request)
            request = pickle.loads(verified_request)
            if (not (request[3] == operation)):
                return False
            self._state.logger.info('validated request for operation in diff_history: %s', operation)
            return True
        except BaseException:
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            self._state.logger.error((('Exception occurred in validation of client request' + 'in diff_history clientid: %s, operation: %s \n') + 'Type: %s\n Value: %s\n Trace: %s'), client_id, operation, exc_type, exc_value, exc_traceback)
            return False

    def validate_slot_number(self, hist, checkpoint_slot_number):
        prev_slot_num = checkpoint_slot_number
        test = sorted(hist.items(), key=(lambda x: int(x[1][0][0])))
        self._state.logger.info(' history sorted on slot numbers: %s ', test)
        for (k, v) in sorted(hist.items(), key=(lambda x: int(x[1][0][0]))):
            if (prev_slot_num is None):
                prev_slot_num = v[0][0]
            elif (not ((prev_slot_num + 1) == v[0][0])):
                self._state.logger.error(('Slot number validation failed for replica history.' + 'Inconsistent values are: %s and %s'), prev_slot_num, v[0][0])
                return False
            else:
                prev_slot_num = v[0][0]
        self._state.logger.debug('Slot numbers validated successfully in replica history')
        return True

    def process_wedged_statements(self, wedged_statements):
        consistent_checkpoint = self.get_consistent_checkpoint(wedged_statements)
        self._state.logger.debug('consistent checkpoint proof : %s ', consistent_checkpoint)
        if consistent_checkpoint:
            checkpoint_sn = consistent_checkpoint[1][0]
            self._state.last_checkpoint_sn = checkpoint_sn
        else:
            checkpoint_sn = self._state.last_checkpoint_sn
        (longest_history, running_state) = self.get_init_parameters(wedged_statements, checkpoint_sn)
        if ((longest_history == False) or (running_state == False)):
            return False
        self._state.logger.debug('longest consistent history: %s', longest_history)
        self._state.logger.debug('running state: %s ', running_state)
        self.set_up_new_replicas(consistent_checkpoint, longest_history, running_state)
        return True

    def compute_suffix(self, consistent_histories, longest_consistent_history):
        self._state.logger.info('collecting operations to be sent in catch up')
        suffix_hist = OrderedDict()
        for (replica, history) in consistent_histories.items():
            temp_suffix_hist = OrderedDict()
            for (k, v) in longest_consistent_history.items():
                if (not (k in history)):
                    temp_suffix_hist[k] = v
            suffix_hist[replica] = temp_suffix_hist
        return suffix_hist

    def send_catch_up_to_replicas(self, suffix_for_consistent_histories):
        for (replica, catch_up_hist) in suffix_for_consistent_histories.items():
            signed_catch_up_hist = self._state.signing_key.sign(pickle.dumps(catch_up_hist))
            self.send(('catch_up', signed_catch_up_hist), to=replica)
            self._state.logger.info('catch up sent to replica %s : %s ', replica, catch_up_hist)

    def get_responses_for_clients(self, caught_up_msgs, replica_with_longest_hist):
        self._state.logger.info(('getting the results and result statements' + 'for each client last performed operation'))
        resultproof_of_client_op = OrderedDict()
        self._state.invalid_replicas = []
        caught_up_msg_of_longest_hist_repl = caught_up_msgs[replica_with_longest_hist]
        for (c, rs) in caught_up_msg_of_longest_hist_repl[2].items():
            unpickled_result_stmt = pickle.loads(self._state.public_keys[caught_up_msg_of_longest_hist_repl[0]].verify(rs[1]))
            resultproof_of_client_op[c] = (unpickled_result_stmt[1], rs[0], self._state.configuration, [rs[1]])
        for (replica, value) in caught_up_msgs.items():
            if (not (replica == replica_with_longest_hist)):
                for (client_id, val) in value[2].items():
                    unpickled_result_stmt = pickle.loads(self._state.public_keys[value[0]].verify(val[1]))
                    cryptographic_hash_of_res = self.get_hashed_result(val[0])
                    if ((val[0] == resultproof_of_client_op[client_id][1]) and (cryptographic_hash_of_res == unpickled_result_stmt[2])):
                        resultproof_of_client_op[client_id][3].append(val[1])
                    else:
                        self._state.logger.error(('validation failed for result for' + 'client: %s. Marking replica: %s invalid '), client_id, replica)
                        return False
        for (client_id, result_proof) in resultproof_of_client_op.items():
            req_id = caught_up_msg_of_longest_hist_repl[2][client_id][2]
            response = (req_id, (result_proof[1], result_proof), self.get_replicas_id(caught_up_msgs.keys()))
            signed_response = self._state.signing_key.sign(pickle.dumps(response))
            self._state.client_responses[client_id] = signed_response
            self._state.logger.info('saved response to request id: %s of client : %s ', req_id, client_id)
        self._state.logger.info('all replicas in quorum are valid.')
        return True

    def get_replicas_id(self, replicas_obj):
        self._state.logger.info('getting replicas id')
        replicas_id = [k for r in replicas_obj for (k, v) in self._state.configuration.items() if (r == v)]
        return replicas_id

    def get_hashed_result(self, result):
        HASHER = nacl.hash.sha256
        result_bytes = pickle.dumps(result)
        digest = HASHER(result_bytes, encoder=nacl.encoding.HexEncoder)
        result_bytes = pickle.dumps(result)
        digest = HASHER(result_bytes, encoder=nacl.encoding.HexEncoder)
        self._state.logger.info('result: %s\n cryptographic hash of the result: %s', result, digest)
        return digest

    def reconfigure(self):
        if self._state.reconfig_in_progress:
            return
        self._state.reconfig_in_progress = True
        self._state.logger.info('reconfiguring...')
        self._state.global_wedged_statements = OrderedDict()
        self._state.caught_up_msgs = OrderedDict()
        self._state.consistent_running_state = None
        self._state.old_head = None
        self._state.client_responses = OrderedDict()
        self._state.QC = []
        self.build_quorum_combinations()
        for i in range(len(self._state.configuration)):
            signed_wedge_request = self._state.signing_key.sign(pickle.dumps('wedge'))
            self.send(('wedge', signed_wedge_request), to=self._state.configuration[('replica' + str(i))])
            self._state.logger.info('sent wedge request to replica%s ', i)
        super()._label('_st_label_2727', block=False)
        _st_label_2727 = 0
        while (_st_label_2727 == 0):
            _st_label_2727 += 1
            if (len(self._state.global_wedged_statements) >= (self._state.config['t'] + 1)):
                _st_label_2727 += 1
            else:
                super()._label('_st_label_2727', block=True)
                _st_label_2727 -= 1
        self._state.logger.debug('wedged statments received from quorum of replicas')
        while (self._state.reconfig_in_progress and self._state.QC):
            selected_quorum = None
            q_replicas = self._state.global_wedged_statements.keys()
            received_len_replicas = len(q_replicas)
            for item in self._state.QC:
                wedged_statements = OrderedDict()
                for r in item:
                    if (list(r)[0] in q_replicas):
                        wedged_statements[list(r)[0]] = self._state.global_wedged_statements[list(r)[0]]
                if (len(wedged_statements) == self._state.quorum):
                    selected_quorum = item
                    self._state.logger.info('processing wedged statements of selected quorum %s', selected_quorum)
                    self.process_wedged_statements(wedged_statements)
                    break
            if ((not (selected_quorum is None)) and self._state.reconfig_in_progress):
                self._state.logger.info(('************************* removing selected' + 'quorum from list QC : %s'), self._state.QC)
                self._state.QC.remove(selected_quorum)
                self._state.logger.info(('************************* waiting for third' + 'replica wedge statement'))
                super()._label('_st_label_2845', block=False)
                _st_label_2845 = 0
                while (_st_label_2845 == 0):
                    _st_label_2845 += 1
                    if ((len(self._state.global_wedged_statements) > received_len_replicas) or (len(self._state.global_wedged_statements) == self._state.num_replicas)):
                        _st_label_2845 += 1
                    else:
                        super()._label('_st_label_2845', block=True)
                        _st_label_2845 -= 1
                else:
                    if (_st_label_2845 != 2):
                        continue
                if (_st_label_2845 != 2):
                    break
                self._state.logger.info(('************************* received third' + 'replica wedge statement'))

    def verify_message_from_replica(self, message, replica):
        self._state.logger.info('validating message received from replica %s', replica)
        for i in range(len(self._state.configuration)):
            if (replica in self._state.configuration[('replica' + str(i))]):
                replica_verify_key = self._state.public_keys[i]
                try:
                    verified_message = replica_verify_key.verify(message)
                    unpickled_message = pickle.loads(verified_message)
                    return unpickled_message
                except BaseException:
                    (exc_type, exc_value, exc_traceback) = sys.exc_info()
                    self._state.logger.error((('Exception occurred in validation' + 'of message from replica') + '\nType: %s\n Value: %s\n Trace: %s'), exc_type, exc_value, exc_traceback)

    def validate_result_statement(self, cryptographic_hash_of_result, result_statement, replica_verify_key, i):
        self._state.logger.info('validating result statement')
        try:
            verified_result_statement = replica_verify_key.verify(result_statement)
            unpickled_result_statement = pickle.loads(verified_result_statement)
            if (not (cryptographic_hash_of_result == unpickled_result_statement[2])):
                self._state.logger.warning('validation failed for  result statement of replica %s', i)
                return False
            return True
        except BaseException:
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            self._state.logger.error('Exception occurred in validating result statement\n Type: %s', exc_type)
            return False

    def set_up_new_replicas(self, consistent_checkpoint, longest_history, running_state):
        old_configuration = self._state.configuration
        self._state.old_head = self._state.configuration['replica0']
        replicas = self.build_replicas(self._state.config)
        self.start_replicas(replicas)
        self.generate_replicas_keys()
        self.send_init_to_replicas(replicas, consistent_checkpoint, longest_history, running_state)
        self.notify_all_clients()
        self.send('test', to=self._state.old_head)
        self.send('test', to=self._state.configuration['replica0'])
        self.exit_old_config_replicas(old_configuration)
        self._state.logger.info('system reinitialized successfully')
        self._state.reconfig_in_progress = False
        self._state.logger.debug(' flag reconfig_in_progress set to : %s ', self._state.reconfig_in_progress)

    def exit_old_config_replicas(self, old_configuration):
        for replica in old_configuration.keys():
            self.send('exit_from_run', to=old_configuration[replica])
        self._state.logger.info(' sent exit message to all replicas')

    def notify_all_clients(self):
        for client_id in self._state.client_responses.keys():
            notification = (self._state.configuration, self._state.public_keys_bytes, self._state.client_responses[client_id])
            signed_notification = self._state.signing_key.sign(pickle.dumps(notification))
            self.send(('new_config_response', signed_notification), to=self._state.clients[client_id])
            self._state.logger.info('sent notification to client. Message sent: %s', notification)

    def _Olympus_handler_961(self, client):
        self._state.done_count += 1
        self._state.logger.info('client :  %s done sending messages. Crrent done_count: %s', client, self._state.done_count)
    _Olympus_handler_961._labels = None
    _Olympus_handler_961._notlabels = None

    def _Olympus_handler_980(self, sender, client_id):
        self._state.logger.info(('received client request for configuration' + 'from client with ID : %s'), client_id)
        if self._state.reconfig_in_progress:
            self._state.logger.info(('reconfiguration in progress.' + 'Ignoring client request for configuration'))
            return
        super()._label('_st_label_1010', block=False)
        _st_label_1010 = 0
        while (_st_label_1010 == 0):
            _st_label_1010 += 1
            if (len(self._state.configuration) == self._state.num_replicas):
                _st_label_1010 += 1
            else:
                super()._label('_st_label_1010', block=True)
                _st_label_1010 -= 1
        self._state.logger.info('Total replicas in configuration: %s', self._state.num_replicas)
        self.send(('configuration', self._state.configuration, self._state.public_keys_bytes), to=sender)
        self._state.logger.info('configuration sent to client: \n configuration: %s', self._state.configuration)
    _Olympus_handler_980._labels = None
    _Olympus_handler_980._notlabels = None

    def _Olympus_handler_1036(self, client_id, key, sender):
        self._state.logger.info(' received public key of client : %s', sender)
        self._state.client_keys_bytes[sender] = key
        self._state.client_keys[sender] = nacl.signing.VerifyKey(key, encoder=nacl.encoding.HexEncoder)
        self._state.clients[client_id] = sender
        self._state.logger.info('sending client public key to all replicas')
        self.send_client_public_key_to_replicas(sender, key)
        self._state.logger.info('sending acknowledgement to client on receipt of it public key')
        self.send(('public_key_received', self._state.public_keys_bytes, self._state.verify_key_hex), to=sender)
    _Olympus_handler_1036._labels = None
    _Olympus_handler_1036._notlabels = None

    def _Olympus_handler_1100(self, replica_id, data):
        self._state.replica_data[replica_id] = data
        self._state.logger.info('received final state of replica %s', replica_id)
    _Olympus_handler_1100._labels = None
    _Olympus_handler_1100._notlabels = None

    def _Olympus_handler_1825(self, signed_rs, rpl):
        verified_rs = self.verify_message_from_replica(signed_rs, rpl)
        self._state.consistent_running_state = verified_rs
        self._state.logger.info('running state received from replica : %s', verified_rs)
    _Olympus_handler_1825._labels = None
    _Olympus_handler_1825._notlabels = None

    def _Olympus_handler_2630(self, reconfiguration_request, replica):
        self.verify_message_from_replica(reconfiguration_request, replica)
        self._state.logger.info('sending signed wedge requests to each replica')
        self.reconfigure()
    _Olympus_handler_2630._labels = None
    _Olympus_handler_2630._notlabels = None

    def _Olympus_handler_2864(self, wedged_statement, replica):
        wedged_statement_from_replica = self.verify_message_from_replica(wedged_statement, replica)
        self._state.global_wedged_statements[replica] = wedged_statement_from_replica
        self._state.logger.info(('verified wedged message from' + 'replica: %s wedged_statement received: %s '), wedged_statement_from_replica, replica)
    _Olympus_handler_2864._labels = None
    _Olympus_handler_2864._notlabels = None

    def _Olympus_handler_2973(self, signed_caught_up_message, replica):
        unpickled_caught_up_msg = self.verify_message_from_replica(signed_caught_up_message, replica)
        self._state.caught_up_msgs[replica] = unpickled_caught_up_msg
        self._state.logger.info('received caught_up message from replica: %s', unpickled_caught_up_msg)
    _Olympus_handler_2973._labels = None
    _Olympus_handler_2973._notlabels = None

    def _Olympus_handler_3003(self, signed_proof_of_misbehaviour, client):
        client_verify_key = self._state.client_keys[client]
        proof_of_misbehaviour = pickle.loads(client_verify_key.verify(signed_proof_of_misbehaviour))
        self._state.logger.debug(('reconfiguration request received from client.' + 'Message received: %s'), ('request_reconfiguration_from_client', proof_of_misbehaviour))
        (res, res_proof) = proof_of_misbehaviour
        result_statements = res_proof[3]
        cryptographic_hash_of_result = self.get_hashed_result(res)
        for i in range(len(self._state.configuration)):
            result_statement = result_statements[i]
            replica_verify_key = self._state.public_keys[i]
            self._state.logger.info('validating result statement of replica %s', i)
            if (not self.validate_result_statement(cryptographic_hash_of_result, result_statement, replica_verify_key, i)):
                self._state.logger.debug((('proof of misbehaviour from client' + 'verified successfully.') + 'initiating reconfiguration.'))
                self.reconfigure()
                return
    _Olympus_handler_3003._labels = None
    _Olympus_handler_3003._notlabels = None

    def _Olympus_handler_3299(self, val, repl):
        if (self._state.old_head == repl):
            self._state.logger.info('t from old_replica %s', val)
        else:
            self._state.logger.info('t from new_replica %s', val)
    _Olympus_handler_3299._labels = None
    _Olympus_handler_3299._notlabels = None
