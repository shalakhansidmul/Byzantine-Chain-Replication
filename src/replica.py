# -*- generated by 1.0.11 -*-
import da
PatternExpr_1683 = da.pat.TuplePattern([da.pat.ConstantPattern('wedge'), da.pat.FreePattern('wedge_request')])
PatternExpr_1690 = da.pat.FreePattern('olympus')
PatternExpr_3273 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_3431 = da.pat.TuplePattern([da.pat.ConstantPattern('request'), da.pat.FreePattern('client_request')])
PatternExpr_3438 = da.pat.FreePattern('sender')
PatternExpr_3504 = da.pat.TuplePattern([da.pat.ConstantPattern('forwarded_request'), da.pat.FreePattern('validated_client_request'), da.pat.FreePattern('client_request')])
PatternExpr_3513 = da.pat.FreePattern('sender')
PatternExpr_3570 = da.pat.TuplePattern([da.pat.ConstantPattern('shuttle'), da.pat.FreePattern('shuttle'), da.pat.FreePattern('sender')])
PatternExpr_3668 = da.pat.TuplePattern([da.pat.ConstantPattern('init'), da.pat.FreePattern('config'), da.pat.FreePattern('private_key_hex'), da.pat.FreePattern('public_keys_hex'), da.pat.FreePattern('olympus_public_key_hex')])
PatternExpr_3740 = da.pat.TuplePattern([da.pat.ConstantPattern('result_shuttle'), da.pat.FreePattern('shuttle')])
PatternExpr_3792 = da.pat.ConstantPattern('exit_from_run')
PatternExpr_3796 = da.pat.FreePattern('ol')
PatternExpr_4083 = da.pat.TuplePattern([da.pat.ConstantPattern('receipt'), da.pat.TuplePattern([da.pat.FreePattern('client_id'), da.pat.FreePattern('request_id'), da.pat.FreePattern('order_proof'), da.pat.FreePattern('result_proof'), da.pat.FreePattern('client_request')])])
PatternExpr_4099 = da.pat.BoundPattern('_BoundPattern4103_')
PatternExpr_4138 = da.pat.TuplePattern([da.pat.ConstantPattern('client_key'), da.pat.FreePattern('client'), da.pat.FreePattern('key')])
PatternExpr_4166 = da.pat.TuplePattern([da.pat.ConstantPattern('checkpoint'), da.pat.FreePattern('checkpoint')])
PatternExpr_4173 = da.pat.FreePattern('predecessor')
PatternExpr_4516 = da.pat.TuplePattern([da.pat.ConstantPattern('result_checkpoint'), da.pat.FreePattern('checkpt')])
PatternExpr_4839 = da.pat.TuplePattern([da.pat.ConstantPattern('catch_up'), da.pat.FreePattern('signed_catch_up_hist')])
PatternExpr_4846 = da.pat.FreePattern('olympus')
PatternExpr_5034 = da.pat.TuplePattern([da.pat.ConstantPattern('init_setup'), da.pat.FreePattern('config'), da.pat.FreePattern('private_key_hex'), da.pat.FreePattern('public_keys_hex'), da.pat.FreePattern('olympus_public_key_hex'), da.pat.FreePattern('client_keys'), da.pat.FreePattern('consistent_checkpoint_sn'), da.pat.FreePattern('longest_history'), da.pat.FreePattern('running_state'), da.pat.FreePattern('t')])
PatternExpr_5056 = da.pat.FreePattern('olympus')
PatternExpr_5256 = da.pat.ConstantPattern('test')
PatternExpr_5260 = da.pat.FreePattern('oly')
PatternExpr_5271 = da.pat.ConstantPattern('get_init_running_state')
PatternExpr_3278 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
_config_object = {'channel': {'fifo', 'reliable'}, 'clock': 'lamport'}
import sys
import os
import copy
import time
import logging
import pickle
import nacl.encoding
import nacl.hash
import nacl.signing
import nacl
from nacl.bindings.utils import sodium_memcmp
from collections import OrderedDict
from copy import deepcopy

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_1683, sources=[PatternExpr_1690], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1682]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_3273, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_3431, sources=[PatternExpr_3438], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3430]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_3504, sources=[PatternExpr_3513], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3503]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_3570, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3569]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_3668, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3667]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_3740, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3739]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_7', PatternExpr_3792, sources=[PatternExpr_3796], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3791]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_8', PatternExpr_4083, sources=[PatternExpr_4099], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4082]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_9', PatternExpr_4138, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4137]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_10', PatternExpr_4166, sources=[PatternExpr_4173], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4165]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_11', PatternExpr_4516, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4515]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_12', PatternExpr_4839, sources=[PatternExpr_4846], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4838]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_13', PatternExpr_5034, sources=[PatternExpr_5056], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5033]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_14', PatternExpr_5256, sources=[PatternExpr_5260], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5255]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_15', PatternExpr_5271, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5270])])

    def setup(self, args, olympus, is_head, is_tail, replica_number, config_id, olympus_public_key_hex, **rest_5321):
        super().setup(args=args, olympus=olympus, is_head=is_head, is_tail=is_tail, replica_number=replica_number, config_id=config_id, olympus_public_key_hex=olympus_public_key_hex, **rest_5321)
        self._state.args = args
        self._state.olympus = olympus
        self._state.is_head = is_head
        self._state.is_tail = is_tail
        self._state.replica_number = replica_number
        self._state.config_id = config_id
        self._state.olympus_public_key_hex = olympus_public_key_hex
        self._state.config_id = self._state.config_id
        self._state.test = False
        self._state.checkpoint_data = OrderedDict()
        self._state.data = OrderedDict()
        self._state.running_state_copy = None
        if self._state.is_head:
            self._state.timeout = self._state.args['head_timeout']
        else:
            self._state.timeout = self._state.args['nonhead_timeout']
        self._state.quorum = (self._state.args['t'] + 1)
        self._state.slot_number = (- 1)
        self._state.prev_slot_num = (- 1)
        self._state.is_head = self._state.is_head
        self._state.is_tail = self._state.is_tail
        self._state.mode = 'PENDING'
        self._state.configuration = OrderedDict()
        self._state.replica_id = self._state.replica_number
        self._state.result_cache = OrderedDict()
        self._state.latest_result_stmts = OrderedDict()
        self._state.history = OrderedDict()
        self._state.private_key = None
        self._state.public_keys = []
        self._state.clients_public_key = OrderedDict()
        self._state.olympus = self._state.olympus
        self._state.olympus_verify_key = nacl.signing.VerifyKey(self._state.olympus_public_key_hex, encoder=nacl.encoding.HexEncoder)
        self._state.client_request_number = OrderedDict()
        self._state.running_status_request_number = (- 1)
        self._state.forwarded_request_number = OrderedDict()
        self._state.client_result_shuttle_number = OrderedDict()
        self._state.client_req_shuttle_number = OrderedDict()
        self._state.checkpoint_number = (- 1)
        self._state.completed_checkpoint_number = (- 1)
        self._state.wedge_request_number = (- 1)
        self._state.catch_up_number = (- 1)
        self._state.failure_trigger_key = (((('failures[' + str(self._state.config_id)) + ',') + str(self._state.replica_number)) + ']')
        self._state.trigger_failure = OrderedDict()
        if (self._state.failure_trigger_key in self._state.args):
            self._state.trigger_failure = self.build_trigger_failure(self._state.args[self._state.failure_trigger_key])
        self._state.change_operation_flag = False
        self._state.change_result_flag = False
        self._state.increment_slot_flag = False
        self._state.invalid_order_sign_flag = False
        self._state.invalid_result_sign_flag = False
        self._state.truncate_history_flag = False
        self._state.truncate_count = 0
        self._state.drop_result_statement_flag = False
        self._state.drop_checkpt_stmts_flag = False
        self._state.drop_request = False
        self._state.checkpoint_interval = self._state.args['checkpt_interval']
        self._state.latest_checkpoint = (None, None)
        self._state.logger = self.initialize_logger(self._state.args['test_case_name'])
        self._state.logger.info('Replica setup completed')
        self._state.logger.info('initial settings are')
        self._state.logger.info('replica id: %s\n  is_head: %s\n is_tail: %s', self._state.replica_id, self._state.is_head, self._state.is_tail)

    def run(self):
        super()._label('_st_label_3270', block=False)
        _st_label_3270 = 0
        while (_st_label_3270 == 0):
            _st_label_3270 += 1
            if PatternExpr_3278.match_iter(self._ReplicaReceivedEvent_1, SELF_ID=self._id):
                _st_label_3270 += 1
            else:
                super()._label('_st_label_3270', block=True)
                _st_label_3270 -= 1
        self._state.logger.info(('Done message received from Olympus.' + ' Sending current state to Olympus.'))
        self.send(('replica_final_state', self._state.replica_id, self._state.data), to=self._state.olympus)
        self._state.logger.info('Message sent to Olympus: %s ', ('replica_final_state', self._state.replica_id, self._state.data))
        while True:
            pass

    def initialize_logger(self, test_case_name):
        self._state.logger = logging.getLogger(('Replica' + str(self._state.replica_id)))
        self._state.logger.setLevel(logging.DEBUG)
        fh = logging.FileHandler(((('Replica' + str(self._state.replica_id)) + '-log-') + test_case_name))
        fh.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        fh.setFormatter(formatter)
        self._state.logger.addHandler(fh)
        return self._state.logger

    def build_trigger_failure(self, failures):
        failure_trigger_list = failures.split(';')
        trigger_failure_dict = OrderedDict()
        for i in range(len(failure_trigger_list)):
            event_action = failure_trigger_list[i]
            if event_action:
                t_f = event_action.split(',')
                if (len(t_f) == 3):
                    key = ((t_f[0].strip() + ',') + t_f[1].strip())
                    if (key in trigger_failure_dict):
                        trigger_failure_dict[key].append(t_f[2].strip())
                    else:
                        trigger_failure_dict[key] = [t_f[2].strip()]
                else:
                    key = t_f[0].strip()
                    if (key in trigger_failure_dict):
                        trigger_failure_dict[key].append(t_f[1].strip())
                    else:
                        trigger_failure_dict[key] = [t_f[1].strip()]
        return trigger_failure_dict

    def perform_operation(self, operation, state=None):
        self._state.logger.info('performing operation: %s', operation)
        result = None
        op = operation.split("'")
        key = op[1]
        if ('put' in operation):
            value = op[3]
            if state:
                state[op[1]] = op[3]
            else:
                self._state.data[op[1]] = op[3]
            val = 'OK'
        elif ('get' in operation):
            if state:
                if (key in state):
                    val = state[key]
                else:
                    val = ' '
            elif (key in self._state.data):
                val = self._state.data[key]
            else:
                val = ' '
        elif ('slice' in operation):
            slice = op[3].split(':')
            start_index = int(slice[0])
            end_index = int(slice[1])
            if state:
                if (key in state):
                    value = state[key]
                    if ((start_index < end_index) and (end_index <= len(value))):
                        state[key] = value[start_index:end_index]
                        val = 'OK'
                    else:
                        val = 'fail'
                else:
                    val = 'fail'
            elif (key in self._state.data):
                value = self._state.data[key]
                if ((start_index < end_index) and (end_index <= len(value))):
                    self._state.data[key] = value[start_index:end_index]
                    val = 'OK'
                else:
                    val = 'fail'
            else:
                val = 'fail'
        elif ('append' in operation):
            value = op[3]
            if state:
                if (key in state):
                    state[key] += value
                    val = 'OK'
                else:
                    val = 'fail'
            elif (key in self._state.data):
                self._state.data[key] += value
                val = 'OK'
            else:
                val = 'fail'
        result = (val,)
        self._state.logger.info('result of operation: %s', result)
        return result

    def send_shuttle_to_successor(self, shuttle, sender):
        successor = ('replica' + str((self._state.replica_id + 1)))
        self.send(('shuttle', shuttle, sender), to=self._state.configuration[successor])
        self._state.logger.info('shuttle sent to successor : %s\n Message sent: %s', successor, ('shuttle', shuttle, sender))

    def send_result_to_client(self, request_id, response, client):
        self.send(('response', request_id, response), to=client)
        self._state.logger.info('sent response %s to client request with request id: %s', ('response', request_id, response), request_id)

    def cache_result_shuttle(self, shuttle):
        (client_id, request_id, order_proof, result_proof, client_request) = shuttle
        self._state.result_cache[(client_id, request_id)] = (order_proof, result_proof)
        self._state.logger.info('cached result shuttle for client id:%s request id:%s shuttle:%s', client_id, request_id, (order_proof, result_proof))

    def send_result_shuttle(self, shuttle):
        predecessor = ('replica' + str((self._state.replica_id - 1)))
        self.send(('result_shuttle', shuttle), to=self._state.configuration[predecessor])
        self._state.logger.info('shuttle sent to predecessor : %s\n Message sent: %s', predecessor, ('result_shuttle', shuttle))

    def get_hashed_result(self, result):
        HASHER = nacl.hash.sha256
        result_bytes = pickle.dumps(result)
        digest = HASHER(result_bytes, encoder=nacl.encoding.HexEncoder)
        result_bytes = pickle.dumps(result)
        digest = HASHER(result_bytes, encoder=nacl.encoding.HexEncoder)
        self._state.logger.info('result: %s\n cryptographic hash of the result: %s', result, digest)
        return digest

    def pickle_sign_statement(self, statement):
        self._state.logger.debug('signing statement: %s', statement)
        pickled_statement = pickle.dumps(statement)
        signed_statement = self._state.private_key.sign(pickled_statement)
        return signed_statement

    def build_signed_order_statement(self, slot_number, operation):
        statement = ('order', slot_number, operation)
        if self._state.invalid_order_sign_flag:
            self._state.invalid_order_sign_flag = False
            pickled_statement = pickle.dumps(statement)
            faulty_private_key = nacl.signing.SigningKey.generate()
            faulty_signed_statement = faulty_private_key.sign(pickled_statement)
            self._state.logger.debug('FAULT INJECTION : INVALID ORDER SIGNATURE for slot number %s', slot_number)
            return faulty_signed_statement
        return self.pickle_sign_statement(statement)

    def build_signed_result_statement(self, operation, cryptographic_hash_of_result):
        statement = ('result', operation, cryptographic_hash_of_result)
        return self.pickle_sign_statement(statement)

    def validate_order_statements(self, operation, order_statements):
        for i in range(len(order_statements)):
            order_statement = order_statements[i]
            try:
                replica_verify_key = self._state.public_keys[i]
                verified_order_statement = replica_verify_key.verify(order_statement)
                unpickled_order_statement = pickle.loads(verified_order_statement)
                if (not (operation == unpickled_order_statement[2])):
                    self._state.logger.warning((('operation performed [%s]' + ' not equat to operation[%s] in replica%s') + 'order statement'), operation, unpickled_order_statement[2], i)
                    return False
            except BaseException:
                (exc_type, exc_value, exc_traceback) = sys.exc_info()
                self._state.logger.error(((('Exception occurred in' + ' validation of') + ' order statement of replica %s for operation: %s\n') + ' Type: %s\n Value: %s\n Trace: %s'), i, operation, exc_type, exc_value, exc_traceback)
                return False
        return True

    def validate_result_statement(self, cryptographic_hash_of_result, result_statement, replica_verify_key):
        try:
            verified_result_statement = replica_verify_key.verify(result_statement)
            unpickled_result_statement = pickle.loads(verified_result_statement)
            if (not (cryptographic_hash_of_result == unpickled_result_statement[2])):
                self._state.logger.warning('result hash does not match hash in result statement:%s', unpickled_result_statement)
                return False
            return True
        except BaseException:
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            self._state.logger.error(('Exception occurred in validation of result statement %s.\n' + ' Type: %s\n Value: %s\n Trace: %s'), result_statement, exc_type, exc_value, exc_traceback)
            return False

    def validate_result_statements_forward(self, cryptographic_hash_of_result, result_statements):
        for i in range(len(result_statements)):
            result_statement = result_statements[i]
            replica_verify_key = self._state.public_keys[i]
            if (not self.validate_result_statement(cryptographic_hash_of_result, result_statement, replica_verify_key)):
                self._state.logger.warning('invalid result statement found for replica: %s', i)
                return False
        return True

    def validate_result_statements_backward(self, cryptographic_hash_of_result, result_statements):
        for i in range(self._state.replica_id, len(result_statements)):
            replica_verify_key = self._state.public_keys[i]
            result_statement = result_statements[i]
            if (not self.validate_result_statement(cryptographic_hash_of_result, result_statement, replica_verify_key)):
                self._state.logger.warning('invalid result statement found for replica: %s', i)
                return False
        return True

    def validate_slot_number(self, current_slot_number):
        self._state.logger.info('current_slot_number: %s prev_slot_num: %s', current_slot_number, self._state.prev_slot_num)
        if (not ((self._state.prev_slot_num + 1) == current_slot_number)):
            self._state.logger.warning(('invalid slot number found : %s previous slot' + 'number processed : %s'), current_slot_number, self._state.prev_slot_num)
            return False
        for value in self._state.history.values():
            (order_proof, signed_client_request) = value
            if (order_proof[0] == current_slot_number):
                self._state.logger.warning('duplicate slot number found : %s', current_slot_number)
                self._state.logger.warning('previously performed operation : %s ', order_proof[1])
                return False
            if (not ((self._state.prev_slot_num + 1) == current_slot_number)):
                self._state.logger.warning(('invalid slot number found : %s previous' + 'slot number processed : %s'), current_slot_number, self._state.prev_slot_num)
                return False
        self._state.prev_slot_num = current_slot_number
        return True

    def request_for_reconfiguration(self):
        self._state.mode = 'IMMUTABLE'
        reconfig_req = self.pickle_sign_statement('request_reconfiguration')
        self.send(('request_reconfiguration', reconfig_req), to=self._state.olympus)
        self._state.logger.info('reconfiguration request sent to olympus. Message sent: %s', ('request_reconfiguration', reconfig_req))

    def check_wedge_request_failure_trigger(self, m):
        wedge_request_failure_str = (('wedge_request(' + str(m)) + ')')
        self.set_failure_flags(wedge_request_failure_str)

    def process_request_shuttle(self, shuttle, client, sender):
        (client_id, request_id, order_proof, result_proof, signed_client_request) = shuttle
        if ((not self._state.is_head) and (not self.validate_client_request_in_shuttle(order_proof[1], signed_client_request, client))):
            self._state.logger.warning(('Client request validation failed.' + ' requesting reconfiguration\n'))
            self.request_for_reconfiguration()
            return
        if ((not self._state.is_head) and (not self.validate_slot_number(order_proof[0]))):
            self._state.logger.warning('Slot number validation failed. requesting reconfiguration\n')
            self.request_for_reconfiguration()
            return
        if ((not self._state.is_head) and (not self.validate_order_statements(order_proof[1], order_proof[3]))):
            self._state.logger.warning(('Order statement validation failed.' + ' requesting reconfiguration.\n'))
            self.request_for_reconfiguration()
            return
        operation = order_proof[1]
        result = self.perform_operation(operation)
        if ((order_proof[0] % self._state.checkpoint_interval) == (self._state.checkpoint_interval - 1)):
            self._state.checkpoint_data[order_proof[0]] = deepcopy(self._state.data)
        cryptographic_hash_of_result = self.get_hashed_result(result)
        if ((not self._state.is_head) and (not self.validate_result_statements_forward(cryptographic_hash_of_result, result_proof[3]))):
            self._state.logger.warning(('Result statement validation failed.' + ' requesting reconfiguration.\n'))
            self.request_for_reconfiguration()
            return
        if self._state.change_operation_flag:
            self._state.logger.debug((('FAULT INJECTION:' + ' CHANGING OPERATION.\n') + ' actual operation: %s\n changed operation: %s'), operation, "get('x')")
            operation = "get('x')"
            self._state.change_operation_flag = False
        result_statement = self.build_signed_result_statement(operation, cryptographic_hash_of_result)
        self._state.latest_result_stmts[client_id] = (result, result_statement, request_id)
        result_proof[1] = result
        result_proof[3].append(result_statement)
        order_statement = self.build_signed_order_statement(order_proof[0], operation)
        order_proof[3].append(order_statement)
        self._state.history[(client_id, request_id)] = (order_proof, signed_client_request)
        shuttle = (client_id, request_id, order_proof, result_proof, signed_client_request)
        if (not self._state.is_tail):
            if self._state.invalid_result_sign_flag:
                self._state.invalid_result_sign_flag = False
                res_stmt = ('result', operation, cryptographic_hash_of_result)
                pickled_res_stmt = pickle.dumps(res_stmt)
                faulty_private_key = nacl.signing.SigningKey.generate()
                faulty_signed_statement = faulty_private_key.sign(pickled_res_stmt)
                self._state.logger.debug(('FAULT INJECTION : INVALID RESULT SIGNATURE' + ' for slot number %s'), order_proof[0])
                result_proof[3].remove(result_statement)
                result_proof[3].append(faulty_signed_statement)
                shuttle = (client_id, request_id, order_proof, result_proof, signed_client_request)
            self.send_shuttle_to_successor(shuttle, client)
        else:
            if self._state.change_result_flag:
                self._state.logger.debug((('FAULT INJECTION:' + ' CHANGING HASH OF RESULT IN RESULT STATEMENT') + ' IN OUTGOING MESSAGE'))
                result_proof = self.change_result(result_proof)
                self._state.change_result_flag = False
            if self._state.drop_result_statement_flag:
                self._state.logger.debug((('FAULT INJECTION:' + ' DROPPING RESULT STATEMENT OF HEAD FROM') + ' RESULT PROOF IN OUTGOING MESSAGE'))
                result_statements = result_proof[3]
                result_statements.pop(0)
                result_proof[3] = result_statements
            self.cache_result_shuttle(shuttle)
            self.send_result_shuttle((client_id, request_id, order_proof, result_proof, signed_client_request))
            if self._state.invalid_result_sign_flag:
                self._state.invalid_result_sign_flag = False
                res_stmt = ('result', operation, cryptographic_hash_of_result)
                pickled_res_stmt = pickle.dumps(res_stmt)
                faulty_private_key = nacl.signing.SigningKey.generate()
                faulty_signed_statement = faulty_private_key.sign(pickled_res_stmt)
                self._state.logger.debug(('FAULT INJECTION : INVALID RESULT SIGNATURE' + ' for slot number %s'), self._state.slot_number)
                result_proof[3].remove(result_statement)
                result_proof[3].append(faulty_signed_statement)
            self.send_result_to_client(request_id, (result, result_proof), client)

    def build_shuttle(self, slot_number, client_id, request_id, operation, signed_client_request):
        order_proof = [slot_number, operation, self._state.configuration, []]
        result_proof = [operation, ' ', self._state.configuration, []]
        shuttle = (client_id, request_id, order_proof, result_proof, signed_client_request)
        self._state.logger.info('shutle created: %s', (client_id, request_id, order_proof, result_proof, signed_client_request))
        return shuttle

    def build_response(self, client_id, request_id):
        (order_proof, result_proof) = self._state.result_cache[(client_id, request_id)]
        result = result_proof[1]
        if self._state.change_result_flag:
            self._state.logger.debug('FAULT INJECTION:')
            self._state.logger.debug(('CHANGING HASH OF RESULT' + ' IN RESULT STATEMENT IN OUTGOING MESSAGE'))
            result_proof = self.change_result(result_proof)
            self._state.change_result_flag = False
        if self._state.drop_result_statement_flag:
            self._state.logger.debug((('FAULT INJECTION:' + ' DROPPING RESULT STATEMENT OF HEAD FROM') + ' RESULT PROOF IN OUTGOING MESSAGE'))
            result_statements = result_proof[3]
            result_statements.pop(0)
            result_proof[3] = result_statements
        response = (result, result_proof)
        self._state.logger.info('response created for client id: %s request id: %s response: %s', client_id, request_id, response)
        return response

    def change_result(self, result_proof):
        operation = result_proof[0]
        result_statements = result_proof[3]
        cryptographic_hash_of_result = self.get_hashed_result(('OK',))
        changed_result_statement = self.build_signed_result_statement(operation, cryptographic_hash_of_result)
        result_proof[3][self._state.replica_id] = changed_result_statement
        return result_proof

    def send_receipt_to_replica(self, client_id, request_id, signed_client_request, sender):
        (order_proof, result_proof) = self._state.result_cache[(client_id, request_id)]
        receipt = (client_id, request_id, order_proof, result_proof, signed_client_request)
        self.send(('receipt', receipt), to=sender)
        self._state.logger.info('Receipt sent to replica')

    def forward_request_to_head(self, client_request, signed_client_request):
        self.send(('forwarded_request', client_request, signed_client_request), to=self._state.configuration['replica0'])
        self._state.logger.info('Client request forwarded to head. \n Message sent: %s ', ('forwarded_request', client_request))

    def send_error_statement(self, client):
        self.send(('error',), to=client)
        self._state.logger.info('Error statement sent. \n Message sent: %s', ('error',))

    def set_failure_flags(self, req_str):
        if (req_str in self._state.trigger_failure):
            if ('change_operation()' in self._state.trigger_failure[req_str]):
                self._state.change_operation_flag = True
                self._state.logger.debug('trigger: %s for failure: CHANGE OPERATION', req_str)
            elif ('change_result()' in self._state.trigger_failure[req_str]):
                self._state.change_result_flag = True
                self._state.logger.debug('trigger: %s for failure: CHANGE RESULT', req_str)
            elif ('drop_result_stmt()' in self._state.trigger_failure[req_str]):
                self._state.drop_result_statement_flag = True
                self._state.logger.debug('trigger: %s for failure: DROP RESULT STATEMENT', req_str)
            elif ('increment_slot()' in self._state.trigger_failure[req_str]):
                self._state.increment_slot_flag = True
                self._state.logger.debug('trigger: %s for failure: INCREMENT SLOT', req_str)
            elif ('crash()' in self._state.trigger_failure[req_str]):
                self._state.logger.debug('trigger: %s for failure: ', req_str)
                self._state.logger.debug('FAULT INJECTION : CRASH')
                logging.shutdown()
                os._exit((- 1))
            elif ('drop_checkpt_stmts()' in self._state.trigger_failure[req_str]):
                self._state.drop_checkpt_stmts_flag = True
                self._state.logger.debug('trigger: %s for failure: DROP CHECKPOINT STATEMENTS', req_str)
            elif ('sleep(' in self._state.trigger_failure[req_str]):
                val = self._state.trigger_failure[req_str].split('(')
                val1 = val[1].split(')')
                self._state.logger.debug('trigger: %s for failure: Sleep for %s milliseconds', req_str, val1[0])
                time.sleep((int(val1[0]) // 1000))
            elif ('drop()' in self._state.trigger_failure[req_str]):
                self._state.drop_request = True
                self._state.logger.debug('trigger: %s for failure: ', req_str)
                self._state.logger.debug(' ignoring the incoming the request %s', req_str)
            elif ('invalid_order_sig()' in self._state.trigger_failure[req_str]):
                self._state.invalid_order_sign_flag = True
                self._state.logger.debug('trigger: %s for failure: ', req_str)
            elif ('invalid_result_sig()' in self._state.trigger_failure[req_str]):
                self._state.invalid_result_sign_flag = True
                self._state.logger.debug('trigger: %s for failure: ', req_str)
            elif ('extra_op()' in self._state.trigger_failure[req_str]):
                self._state.logger.debug('trigger: %s for failure: ', req_str)
                self._state.logger.debug(('FAULT INJECTION: EXTRA OPERATION.' + ' Data before extra operation: %s '), self._state.data)
                self._state.data['a'] = 'a'
                self._state.logger.debug('Data after extra operation is: %s', self._state.data)
            else:
                for f in self._state.trigger_failure[req_str]:
                    if ('truncate_history(' in f):
                        val = f.split('(')
                        val1 = val[1].split(')')
                        self._state.truncate_history_flag = True
                        self._state.truncate_count = int(val1[0])
                        self._state.logger.debug('trigger: %s for failure: ', req_str)
                    if ('sleep(' in f):
                        val = f.split('(')
                        val1 = val[1].split(')')
                        self._state.logger.debug(('trigger: %s for failure: Sleep' + ' for %s seconds'), req_str, val1[0])
                        time.sleep((int(val1[0]) // 1000))

    def check_failure_trigger_client_request(self, client_request, sender):
        (client_id, client, request_id, operation) = client_request
        if (sender == client):
            req_number = self._state.client_request_number[client_id]
            client_req_str = (((('client_request(' + str(client_id)) + ',') + str(req_number)) + ')')
            self.set_failure_flags(client_req_str)
        else:
            req_number = self._state.forwarded_request_number[client_id]
            forwarded_req_str = (((('forwarded_request(' + str(client_id)) + ',') + str(req_number)) + ')')
            self.set_failure_flags(forwarded_req_str)

    def pre_process(self, client_request, sender):
        (client_id, client, request_id, operation) = client_request
        if (sender == client):
            if (client_id in self._state.client_request_number):
                self._state.client_request_number[client_id] += 1
            else:
                self._state.client_request_number[client_id] = 0
        elif (client_id in self._state.forwarded_request_number):
            self._state.forwarded_request_number[client_id] += 1
        else:
            self._state.forwarded_request_number[client_id] = 0

    def initiate_checkpoint(self, slot_num):
        self._state.logger.info('intiating checkpoint for slot number %s', slot_num)
        checkpoint_proof = []
        cryptographic_hash_of_running_state = self.get_hashed_running_state(self._state.checkpoint_data[slot_num])
        signed_checkpoint_statement = self.build_signed_checkpoint_statement(cryptographic_hash_of_running_state)
        checkpoint_proof.append(signed_checkpoint_statement)
        checkpoint = (slot_num, checkpoint_proof)
        self.forward_checkpoint_shuttle('forward', checkpoint)

    def process_client_request(self, client_request, signed_client_request, sender):
        (client_id, client, request_id, operation) = client_request
        if (self._state.mode == 'ACTIVE'):
            if ((client_id, request_id) in self._state.result_cache):
                self._state.logger.debug(('result found in cache for:\n' + ' request id: %s\n client id: %s'), request_id, client_id)
                response = self.build_response(client_id, request_id)
                if (sender == client):
                    self.send_result_to_client(request_id, response, client)
                else:
                    self.send_receipt_to_replica(client_id, request_id, signed_client_request, sender)
            elif self._state.is_head:
                if ((client_id, request_id) in self._state.history):
                    self._state.logger.debug(('HEAD replica processed operation for client id: %s,' + ' request id: %s . Waiting for result shuttle.'), client_id, request_id)
                    super()._label('_st_label_3094', block=False)
                    _st_label_3094 = 0
                    while (_st_label_3094 == 0):
                        _st_label_3094 += 1
                        if ((client_id, request_id) in self._state.result_cache):
                            _st_label_3094 += 1
                        else:
                            super()._label('_st_label_3094', block=True)
                            _st_label_3094 -= 1
                    response = self.build_response(client_id, request_id)
                    if (sender == client):
                        self.send_result_to_client(request_id, response, client)
                    else:
                        self.send_receipt_to_replica(client_id, request_id, signed_client_request, sender)
                        self.send_result_to_client(request_id, response, client)
                else:
                    self._state.logger.debug(('New request with id: %s' + ' received from client : %s. Processing request.'), request_id, client_id)
                    if self._state.increment_slot_flag:
                        self._state.logger.info('FAULT INJECTION: INCREMENTING SLOT NUMBER')
                        self._state.slot_number += 1
                        self._state.increment_slot_flag = False
                    self._state.slot_number += 1
                    shuttle = self.build_shuttle(self._state.slot_number, client_id, request_id, operation, signed_client_request)
                    self.process_request_shuttle(shuttle, client, sender)
            else:
                self._state.logger.debug(('No result found for client id: %s ,' + ' request id: %s. Forwarding request to head.'), client_id, request_id)
                self.forward_request_to_head(client_request, signed_client_request)
                super()._label('_st_label_3185', block=False)
                _st_label_3185 = 0
                self._timer_start()
                while (_st_label_3185 == 0):
                    _st_label_3185 += 1
                    if ((client_id, request_id) in self._state.result_cache):
                        response = self.build_response(client_id, request_id)
                        self.send_result_to_client(request_id, response, client)
                        self._state.logger.debug((('result for forwarded request obtained in cache. \n' + ' client id: %s, \n request id: %s \n') + ' response sent to client.'), client_id, request_id)
                        _st_label_3185 += 1
                    elif (not (self._state.mode == 'ACTIVE')):
                        self._state.logger.warning(('Replica mode changed to IMMUTABLE.' + ' Terminating from further processing of request.'))
                        return
                        _st_label_3185 += 1
                    elif self._timer_expired:
                        self._state.logger.warning(((('Timeoud out.' + ' No result for client request obtained') + ' within timeout.') + ' Requesting reconfiguration. \n'))
                        self.request_for_reconfiguration()
                        return
                        _st_label_3185 += 1
                    else:
                        super()._label('_st_label_3185', block=True, timeout=self._state.timeout)
                        _st_label_3185 -= 1
        elif (not (self._state.mode == 'ACTIVE')):
            if (sender == client):
                self._state.logger.warning((('Replica is IMMUTABLE.' + ' Cannot perform operation for client id: %s') + ' request id: %s'), client_id, request_id)
                self.send_error_statement(client)

    def validate_client_request(self, client_request, sender):
        try:
            client_verify_key = self._state.clients_public_key[sender]
            verified_request = client_verify_key.verify(client_request)
            request = pickle.loads(verified_request)
            return request
        except BaseException:
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            self._state.logger.error(('Exception occurred in validation' + ' of client request\n Type: %s\n Value: %s\n Trace: %s'), exc_type, exc_value, exc_traceback)
            return False

    def validate_client_request_in_shuttle(self, operation, signed_client_request, client):
        try:
            client_verify_key = self._state.clients_public_key[client]
            verified_request = client_verify_key.verify(signed_client_request)
            request = pickle.loads(verified_request)
            if (not (request[3] == operation)):
                return False
            return True
        except BaseException:
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            self._state.logger.error(('Exception occurred in validation ' + ' of client request\n Type: %s\n Value: %s\n Trace: %s'), exc_type, exc_value, exc_traceback)
            return False

    def pre_process_request_shuttle(self, shuttle):
        (client_id, request_id, order_proof, result_proof, client_request) = shuttle
        if (client_id in self._state.client_req_shuttle_number):
            self._state.client_req_shuttle_number[client_id] += 1
        else:
            self._state.client_req_shuttle_number[client_id] = 0
        self._state.logger.info(('pre_processing request shuttle:' + ' client id: %s request shuttle number: %s'), client_id, self._state.client_req_shuttle_number[client_id])

    def pre_process_result_shuttle(self, shuttle):
        (client_id, request_id, order_proof, result_proof, client_request) = shuttle
        if (client_id in self._state.client_result_shuttle_number):
            self._state.client_result_shuttle_number[client_id] += 1
        else:
            self._state.client_result_shuttle_number[client_id] = 0
        self._state.logger.info(('pre_processing result shuttle:' + ' client id: %s request id: %s result shuttle number: %s'), client_id, request_id, self._state.client_result_shuttle_number[client_id])

    def check_failure_trigger_shuttle(self, shuttle, shuttle_type):
        client_id = shuttle[0]
        if (shuttle_type == 'shuttle'):
            shuttle_number = self._state.client_req_shuttle_number[client_id]
        else:
            shuttle_number = self._state.client_result_shuttle_number[client_id]
        shuttle_str = (((((shuttle_type + '(') + str(client_id)) + ',') + str(shuttle_number)) + ')')
        self.set_failure_flags(shuttle_str)

    def process_result_shuttle(self, result_shuttle):
        (client_id, request_id, order_proof, result_proof, client_request) = result_shuttle
        result = result_proof[1]
        result_statements = result_proof[3]
        cryptographic_hash_of_result = self.get_hashed_result(result)
        if (not self.validate_result_statements_backward(cryptographic_hash_of_result, result_statements)):
            self._state.logger.warning(('Result statements validation failed.' + ' requesting reconfiguration.\n'))
            self.request_for_reconfiguration()
            self._state.mode = 'IMMUTABLE'
            self._state.logger.warning('Replica MODE changed to IMMUTABLE')
            return
        self.cache_result_shuttle(result_shuttle)
        if (not self._state.is_head):
            if self._state.change_result_flag:
                cryptographic_hash_of_result = self.get_hashed_result(('OK',))
                operation = result_proof[0]
                changed_result_statement = self.build_signed_result_statement(operation, cryptographic_hash_of_result)
                result_statements[self._state.replica_id] = changed_result_statement
                result_shuttle[3][3] = result_statements
                self._state.change_result_flag = False
                self._state.logger.debug((('FAULT INJECTION:' + ' CHANGING HASH OF RESULT IN RESULT STATEMENT') + ' IN OUTGOING MESSAGE'))
            if self._state.drop_result_statement_flag:
                result_statements.pop(0)
                result_shuttle[3][3] = result_statements
                self._state.drop_result_statement_flag = False
                self._state.logger.debug('FAULT INJECTION:')
                self._state.logger.debug('DROPPING RESULT STATEMENT OF HEAD IN OUTGOING MESSAGE')
            self.send_result_shuttle(result_shuttle)
        else:
            res_shuttle_slot_num = order_proof[0]
            if ((not (res_shuttle_slot_num == 0)) and ((res_shuttle_slot_num % self._state.checkpoint_interval) == (self._state.checkpoint_interval - 1))):
                self.initiate_checkpoint(res_shuttle_slot_num)
                self._state.logger.debug('checkpoint initated for slot number : %s', res_shuttle_slot_num)

    def check_checkpoint_failure_trigger(self, m):
        checkpoint_failure_str = (('checkpoint(' + str(m)) + ')')
        self.set_failure_flags(checkpoint_failure_str)

    def check_get_running_state_failure_trigger(self, m):
        get_running_state_failure_str = (('get_running_state(' + str(m)) + ')')
        self.set_failure_flags(get_running_state_failure_str)

    def forward_checkpoint_shuttle(self, direction, checkpoint):
        (slot_num, checkpoint_proof) = checkpoint
        if self._state.is_tail:
            self.delete_history(slot_num)
            self._state.latest_checkpoint = (self._state.checkpoint_data[slot_num], checkpoint)
            receiver = ('replica' + str((self._state.replica_id - 1)))
            checkpoint_shuttle = ('result_checkpoint', checkpoint)
        elif (direction == 'forward'):
            receiver = ('replica' + str((self._state.replica_id + 1)))
            checkpoint_shuttle = ('checkpoint', checkpoint)
        else:
            receiver = ('replica' + str((self._state.replica_id - 1)))
            if self._state.drop_checkpt_stmts_flag:
                (slot_num, checkpoint_proof) = checkpoint
                faulty_checkpoint_proof = deepcopy(checkpoint_proof)
                for i in range(self._state.quorum):
                    faulty_checkpoint_proof.remove(checkpoint_proof[i])
                checkpoint = (slot_num, faulty_checkpoint_proof)
                self._state.logger.debug('FAULT INJECTION: DROP CHECKPOINT STATEMENTS')
            checkpoint_shuttle = ('result_checkpoint', checkpoint)
        self._state.logger.info('sending checkpoint shuttle to %s ', receiver)
        self.send(checkpoint_shuttle, to=self._state.configuration[receiver])
        self._state.logger.info('message sent %s ', checkpoint_shuttle)

    def build_signed_checkpoint_statement(self, cryptographic_hash_of_running_state):
        self._state.logger.debug('building signed checkpoint statement')
        checkpoint_statement = ('checkpoint', cryptographic_hash_of_running_state)
        signed_statement = self.pickle_sign_statement(checkpoint_statement)
        return signed_statement

    def get_hashed_running_state(self, running_state=None):
        HASHER = nacl.hash.sha256
        if running_state:
            rs_bytes = pickle.dumps(running_state)
            digest = HASHER(rs_bytes, encoder=nacl.encoding.HexEncoder)
            self._state.logger.info(('running state: %s\n cryptographic hash' + ' of the running state: %s'), running_state, digest)
        else:
            rs_bytes = pickle.dumps(self._state.data)
            digest = HASHER(rs_bytes, encoder=nacl.encoding.HexEncoder)
            self._state.logger.info('running state: %s\n cryptographic hash of the running state: %s', self._state.data, digest)
        return digest

    def check_completed_checkpoint_failure(self, m):
        completed_chkpt_str = (('completed_checkpoint(' + str(m)) + ')')
        self.set_failure_flags(completed_chkpt_str)

    def validate_checkpoint_proof(self, checkpoint_proof, cryptographic_hash_of_running_state):
        self._state.logger.info('validating checkpoint proof')
        unpickled_checkpoint_statements = self.get_unpickled_checkpoint_statements(checkpoint_proof)
        if unpickled_checkpoint_statements:
            for i in range(len(checkpoint_proof)):
                if (not (unpickled_checkpoint_statements[i][1] == cryptographic_hash_of_running_state)):
                    self._state.logger.info('validation failed. Cryptographics hashs are %s %s', unpickled_checkpoint_statements[i][1], cryptographic_hash_of_running_state)
                    return False
            return True

    def get_unpickled_checkpoint_statements(self, checkpoint_proof):
        self._state.logger.info('unpickling checkpoint statement')
        unpickled_checkpoint_statements = []
        for i in range(len(checkpoint_proof)):
            checkpoint_statement = checkpoint_proof[i]
            replica_verify_key = self._state.public_keys[i]
            try:
                verified_checkpoint_statement = replica_verify_key.verify(checkpoint_statement)
                unpickled_checkpoint_statement = pickle.loads(verified_checkpoint_statement)
                unpickled_checkpoint_statements.append(unpickled_checkpoint_statement)
            except BaseException:
                (exc_type, exc_value, exc_traceback) = sys.exc_info()
                self._state.logger.error((('Exception occurred in validation' + ' of result statement %s.\n') + ' Type: %s\n Value: %s\n Trace: %s'), checkpoint_statement, exc_type, exc_value, exc_traceback)
                return False
        return unpickled_checkpoint_statements

    def delete_history(self, slot_num):
        del_history = []
        self._state.logger.info('history before deletion: ', self._state.history)
        for (key, value) in self._state.history.items():
            (order_proof, signed_client_request) = value
            if (order_proof[0] <= slot_num):
                del_history.append(key)
        for i in range(len(del_history)):
            del self._state.history[del_history[i]]
        self._state.logger.info('History upto slot number %s deleted successfully', slot_num)
        self._state.logger.info('history after deletion: %s ', self._state.history)

    def check_failure_trigger_catch_up(self, m):
        catch_up_str = (('catch_up(' + str(m)) + ')')
        self.set_failure_flags(catch_up_str)

    def process_catch_up_operations(self, catch_up_hist):
        self._state.logger.info('processing catch up messages : %s ', catch_up_hist)
        self._state.running_state_copy = copy.deepcopy(self._state.data)
        latest_result_stmts_copy = copy.deepcopy(self._state.latest_result_stmts)
        for (key, value) in catch_up_hist.items():
            operation = value[0][1]
            result = self.perform_operation(operation, self._state.running_state_copy)
            cryptographic_hash_of_result = self.get_hashed_result(result)
            result_statement = self.build_signed_result_statement(operation, cryptographic_hash_of_result)
            latest_result_stmts_copy[key[0]] = (result, result_statement, key[1])
        cryptographic_hash_of_running_state_copy = self.get_hashed_running_state(self._state.running_state_copy)
        self._state.logger.info('sending caught message to olympus: %s %s ', self._state.running_state_copy, latest_result_stmts_copy)
        self.send_caught_up_message(cryptographic_hash_of_running_state_copy, latest_result_stmts_copy)

    def send_caught_up_message(self, hash_of_rs, latest_res_stmts):
        signed_caught_up_message = self.pickle_sign_statement((self._state.replica_id, hash_of_rs, latest_res_stmts))
        self.send(('caught_up', signed_caught_up_message), to=self._state.olympus)
        self._state.logger.info('caught up message sent to olympus : %s ', ('caught_up', signed_caught_up_message))

    def check_failure_trigger_init_setup(self):
        init_setup_str = 'new_configuration(0)'
        self.set_failure_flags(init_setup_str)

    def get_client_keys(self, client_keys):
        for c in client_keys.keys():
            self._state.clients_public_key[c] = nacl.signing.VerifyKey(client_keys[c], encoder=nacl.encoding.HexEncoder)

    def get_slot_num(self, longest_history, checkpt_sn):
        if ((not longest_history) and checkpt_sn):
            return checkpt_sn
        sn = (- 1)
        for (k, v) in longest_history.items():
            if (v[0][0] > sn):
                sn = v[0][0]
        return sn

    def _Replica_handler_1682(self, wedge_request, olympus):
        self._state.logger.info('wedge request received')
        self._state.wedge_request_number += 1
        self.check_wedge_request_failure_trigger(self._state.wedge_request_number)
        if self._state.drop_request:
            self._state.logger.info('dropping the wedge request from olympus')
            self._state.drop_request = False
            return
        if (not self._state.private_key):
            self._state.logger.info(('No private key available.' + 'Cannot send wedged message to olympus.'))
            return
        try:
            self._state.olympus_verify_key.verify(wedge_request)
            self._state.logger.info('wedge request from olympus verified successfully')
            self._state.mode = 'IMMUTABLE'
            self._state.logger.warning('Replica MODE changed to IMMUTABLE')
        except BaseException:
            (exc_type, exc_value, exc_traceback) = sys.exc_info()
            self._state.logger.error((('Exception occurred in validation of' + 'wedge request from olympus') + '\nType: %s\n Value: %s\n Trace: %s'), exc_type, exc_value, exc_traceback)
        if self._state.truncate_history_flag:
            self._state.logger.debug(('FAULT INJECTION: TRUNCATE HISTORY.' + 'HISTORY BEFORE TRUNCATION %s '), self._state.history)
            history_copy = deepcopy(self._state.history)
            k = list(self._state.history.keys())
            l = len(self._state.history)
            for i in range((l - 1), ((l - self._state.truncate_count) - 1), (- 1)):
                if (i >= 0):
                    self._state.logger.debug('Deleting entry for client request %s', k[i])
                    del history_copy[k[i]]
            self._state.logger.debug(('FAULT INJECTION: TRUNCATE HISTORY.' + ' HISTORY AFTER TRUNCATION %s '), history_copy)
            self._state.truncate_history_flag = False
            self._state.truncate_count = 0
            signed_wedged_statement = self.pickle_sign_statement((self._state.latest_checkpoint[0], self._state.latest_checkpoint[1], history_copy))
        else:
            signed_wedged_statement = self.pickle_sign_statement((self._state.latest_checkpoint[0], self._state.latest_checkpoint[1], self._state.history))
        self.send(('wedged', signed_wedged_statement), to=olympus)
        self._state.logger.info('wedged statement sent to olympus. \nMessage sent: %s', signed_wedged_statement)
    _Replica_handler_1682._labels = None
    _Replica_handler_1682._notlabels = None

    def _Replica_handler_3430(self, client_request, sender):
        if (not (self._state.mode == 'ACTIVE')):
            self._state.logger.warning('Replica is IMMUTABLE. Cannot process received request.')
            return
        self._state.logger.info('client request received: %s', ('request', client_request))
        validated_client_req = self.validate_client_request(client_request, sender)
        if validated_client_req:
            self._state.logger.info('Validated client request: %s', validated_client_req)
            self.pre_process(validated_client_req, sender)
            self.check_failure_trigger_client_request(validated_client_req, sender)
            if self._state.drop_request:
                self._state.logger.info('dropping the client request')
                self._state.drop_request = False
                return
            self.process_client_request(validated_client_req, client_request, sender)
    _Replica_handler_3430._labels = None
    _Replica_handler_3430._notlabels = None

    def _Replica_handler_3503(self, validated_client_request, client_request, sender):
        if (not (self._state.mode == 'ACTIVE')):
            self._state.logger.warning('Replica is IMMUTABLE. Cannot process received request.')
            return
        self._state.logger.info('Forwarded request received %s', ('forwarded_request', validated_client_request))
        self.pre_process(validated_client_request, sender)
        client_id = validated_client_request[0]
        self.check_failure_trigger_client_request(validated_client_request, sender)
        if self._state.drop_request:
            self._state.logger.info('dropping the forwarded client request from replica')
            self._state.drop_request = False
            return
        self.process_client_request(validated_client_request, client_request, sender)
    _Replica_handler_3503._labels = None
    _Replica_handler_3503._notlabels = None

    def _Replica_handler_3569(self, shuttle, sender):
        if (not (self._state.mode == 'ACTIVE')):
            self._state.logger.warning('Replica is IMMUTABLE. Cannot process recieved shuttle.')
            return
        self._state.logger.info('Shuttle received from predecessor replica : %s', ('shuttle', shuttle, sender))
        self.pre_process_request_shuttle(shuttle)
        self.check_failure_trigger_shuttle(shuttle, 'shuttle')
        if self._state.drop_request:
            self._state.logger.info('dropping the shuttle from predecessor')
            self._state.drop_request = False
            return
        self.process_request_shuttle(shuttle, sender, sender)
    _Replica_handler_3569._labels = None
    _Replica_handler_3569._notlabels = None

    def _Replica_handler_3667(self, config, private_key_hex, public_keys_hex, olympus_public_key_hex):
        self._state.logger.info('Init message received from Olympus: %s', ('init', config, private_key_hex, public_keys_hex))
        self._state.configuration = config
        self._state.private_key = nacl.signing.SigningKey(private_key_hex, encoder=nacl.encoding.HexEncoder)
        for key in public_keys_hex:
            public_key = nacl.signing.VerifyKey(key, encoder=nacl.encoding.HexEncoder)
            self._state.public_keys.append(public_key)
        self._state.olympus_verify_key = nacl.signing.VerifyKey(olympus_public_key_hex, encoder=nacl.encoding.HexEncoder)
        self._state.mode = 'ACTIVE'
    _Replica_handler_3667._labels = None
    _Replica_handler_3667._notlabels = None

    def _Replica_handler_3739(self, shuttle):
        if (not (self._state.mode == 'ACTIVE')):
            self._state.logger.warning('Replica is IMMUTABLE. Cannot process recieved result shuttle')
            return
        self._state.logger.info('result shuttle received from successor replica: %s', ('result_shuttle', shuttle))
        self.pre_process_result_shuttle(shuttle)
        self.check_failure_trigger_shuttle(shuttle, 'result_shuttle')
        if self._state.drop_request:
            self._state.logger.info('dropping the result shuttle')
            self._state.drop_request = False
            return
        self.process_result_shuttle(shuttle)
    _Replica_handler_3739._labels = None
    _Replica_handler_3739._notlabels = None

    def _Replica_handler_3791(self, ol):
        if (ol == self._state.olympus):
            self._state.logger.info('exiting by replica%s in old configuration', self._state.replica_id)
            os._exit((- 1))
            self._state.logger.info('exited by replica%s in old configuration', self._state.replica_id)
    _Replica_handler_3791._labels = None
    _Replica_handler_3791._notlabels = None

    def _Replica_handler_4082(self, client_id, request_id, order_proof, result_proof, client_request):
        if (not (self._state.mode == 'ACTIVE')):
            self._state.logger.warning(('Replica is IMMUTABLE.' + ' Cannot process recieved receipt from head.'))
            return
        response_from_head = (client_id, request_id, order_proof, result_proof, client_request)
        self._state.logger.info('receipt from head for forwarded request: %s', response_from_head)
        self.cache_result_shuttle(response_from_head)
    _Replica_handler_4082._labels = None
    _Replica_handler_4082._notlabels = None

    def _Replica_handler_4137(self, client, key):
        self._state.clients_public_key[client] = nacl.signing.VerifyKey(key, encoder=nacl.encoding.HexEncoder)
        self._state.logger.info('clients public key received from olympus')
    _Replica_handler_4137._labels = None
    _Replica_handler_4137._notlabels = None

    def _Replica_handler_4165(self, checkpoint, predecessor):
        if (not (self._state.mode == 'ACTIVE')):
            self._state.logger.warning(('Replica is IMMUTABLE.' + ' Cannot process received checkpoint shuttle'))
            return
        self._state.checkpoint_number += 1
        self._state.logger.info('checkpoint shuttle received from predecessor replica: %s', checkpoint)
        self.check_checkpoint_failure_trigger(self._state.checkpoint_number)
        if self._state.drop_request:
            self._state.logger.info(('dropping the checkpoint shuttle' + ' received from predecessor replica'))
            self._state.drop_request = False
            return
        (slot_num, checkpoint_proof) = checkpoint
        cryptographic_hash_of_running_state = self.get_hashed_running_state(self._state.checkpoint_data[slot_num])
        isValid = self.validate_checkpoint_proof(checkpoint_proof, cryptographic_hash_of_running_state)
        if isValid:
            signed_checkpoint_statement = self.build_signed_checkpoint_statement(cryptographic_hash_of_running_state)
            checkpoint_proof.append(signed_checkpoint_statement)
            checkpoint = (slot_num, checkpoint_proof)
            self.forward_checkpoint_shuttle('forward', checkpoint)
        else:
            self._state.logger.warning(('Checkpoint proof validation failed.' + ' Requesting reconfiguration'))
            self.request_for_reconfiguration()
            return
    _Replica_handler_4165._labels = None
    _Replica_handler_4165._notlabels = None

    def _Replica_handler_4515(self, checkpt):
        if (not (self._state.mode == 'ACTIVE')):
            self._state.logger.warning(('Replica is IMMUTABLE. Cannot process' + ' recieved result checkpoint shuttle'))
            return
        self._state.completed_checkpoint_number += 1
        self.check_completed_checkpoint_failure(self._state.completed_checkpoint_number)
        if self._state.drop_request:
            self._state.logger.info(('dropping the completed checkpoint shuttle' + ' received from successor replica'))
            self._state.drop_request = False
            return
        self._state.logger.info('result checkpoint shuttle received from successor replica: %s', checkpt)
        (slot_num, checkpoint_proof) = checkpt
        self._state.logger.info('validating checkpoint proofs for slot number: %s', slot_num)
        cryptographic_hash_of_running_state = self.get_hashed_running_state(self._state.checkpoint_data[slot_num])
        isValid = self.validate_checkpoint_proof(checkpoint_proof, cryptographic_hash_of_running_state)
        if isValid:
            self.delete_history(slot_num)
            self._state.latest_checkpoint = (self._state.checkpoint_data[slot_num], checkpt)
            if (not self._state.is_head):
                self.forward_checkpoint_shuttle('backward', checkpt)
        else:
            self._state.logger.warning(('Checkpoint proof validation failed.' + ' Requesting reconfiguration'))
            self.request_for_reconfiguration()
            return
    _Replica_handler_4515._labels = None
    _Replica_handler_4515._notlabels = None

    def _Replica_handler_4838(self, signed_catch_up_hist, olympus):
        self._state.logger.info('received catch up from olympus')
        self._state.catch_up_number += 1
        self.check_failure_trigger_catch_up(self._state.catch_up_number)
        if self._state.drop_request:
            self._state.logger.debug(('FAULT INJECTION: DROP for catch' + 'up message received from olympus'))
            self._state.drop_request = False
            return
        verified_catch_up_hist = self._state.olympus_verify_key.verify(signed_catch_up_hist)
        unpickled_catch_up_hist = pickle.loads(verified_catch_up_hist)
        self._state.logger.info('unpickled_catch_up_hist : %s', unpickled_catch_up_hist)
        self.process_catch_up_operations(unpickled_catch_up_hist)
    _Replica_handler_4838._labels = None
    _Replica_handler_4838._notlabels = None

    def _Replica_handler_5033(self, config, private_key_hex, public_keys_hex, olympus_public_key_hex, client_keys, consistent_checkpoint_sn, longest_history, running_state, t, olympus):
        self._state.logger.info('init_setup message received from Olympus: %s', ('init_setup', config, private_key_hex, public_keys_hex, olympus_public_key_hex, client_keys, consistent_checkpoint_sn, longest_history, running_state))
        self.check_failure_trigger_init_setup()
        if self._state.drop_request:
            self._state.logger.debug('FAULT INJECTION: Dropping Init setup message from olympus')
            self._state.drop_request = False
            return
        self._state.test = t
        self._state.configuration = config
        self._state.private_key = nacl.signing.SigningKey(private_key_hex, encoder=nacl.encoding.HexEncoder)
        for key in public_keys_hex:
            public_key = nacl.signing.VerifyKey(key, encoder=nacl.encoding.HexEncoder)
            self._state.public_keys.append(public_key)
        self._state.olympus_verify_key = nacl.signing.VerifyKey(olympus_public_key_hex, encoder=nacl.encoding.HexEncoder)
        self.get_client_keys(client_keys)
        checkpt_sn = consistent_checkpoint_sn
        self._state.data = running_state
        if (longest_history or checkpt_sn):
            self._state.prev_slot_num = self.get_slot_num(longest_history, checkpt_sn)
            self._state.slot_number = self._state.prev_slot_num
        self._state.history = longest_history
        self._state.logger.info('client_req_shuttle_number is %s', self._state.client_req_shuttle_number)
        self._state.logger.info('init setup completed successfully')
        self._state.mode = 'ACTIVE'
    _Replica_handler_5033._labels = None
    _Replica_handler_5033._notlabels = None

    def _Replica_handler_5255(self, oly):
        self.send(('test_resp', self._state.test), to=oly)
    _Replica_handler_5255._labels = None
    _Replica_handler_5255._notlabels = None

    def _Replica_handler_5270(self):
        self._state.logger.info('received request for running state from olympus')
        self._state.running_status_request_number += 1
        self.check_get_running_state_failure_trigger(self._state.running_status_request_number)
        if self._state.drop_request:
            self._state.logger.info('dropping the get running state request from olympus')
            self._state.drop_request = False
            return
        data_to_send = self._state.running_state_copy
        signed_rs = self.pickle_sign_statement(data_to_send)
        self.send(('init_running_state', signed_rs), to=self._state.olympus)
        self._state.logger.info('Message sent: %s ', ('init_running_state', self._state.running_state_copy))
    _Replica_handler_5270._labels = None
    _Replica_handler_5270._notlabels = None
